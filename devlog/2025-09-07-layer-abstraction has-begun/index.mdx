---
title: "Layer Abstraction initiated"
description: "Architecting the rendering and scene layer - from Vertex to MeshData to device-specific Meshes"
tags: [devlog, helios]
keywords: [cpp, game engine architecture, rendering layer, scene graph, vertex, mesh, glfw, opengl, testing]
authors: [thorstensuckow]
---

import {SocialLinks} from "../../src/components/SocialLinks";

### This time, there will be no Feature Creep - I promise!

From `Vertex` to `MeshData` to device-specific `Meshes` - over the weekend, I took a sidestep from the math lib to focus on the architectural planning and development of the underlying rendering layer, accompanied by the scene layer that is responsible for abstracting scene graphs away from the actual rendering process.

<!--truncate-->

### Testing and Examples
I set up a testing infrastructure with `glm` as a reference for validating my own implementations. Added an examples subsystem with `GLFW` windowing and `glad` OpenGL context management.

### Architecture First
The real test isn't whether helios can render a triangle - it's whether these early decisions hold up with complex, dynamic scenes. In software architecture, a well-laid-out plan matters. And the deepest insights come from refactoring.


<SocialLinks />



