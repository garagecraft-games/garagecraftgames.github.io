---
slug: establishing-the-stransformation-library
title: "Establishing the Transformation Library"
tags: [devlog, helios]
keywords: [indiedev, gamedev, solodev, cpp, programming, linear algebra, computer graphics, indiegames]
---

import {SocialLinks} from "../../src/components/SocialLinks";

This weekend's development on the [helios engine](/helios) centered on finalizing transformation logic within [`helios.math`](https://github.com/ThorstenSuckow/helios/tree/main/src/helios/math).

The transformation functions `translate`, `rotate`, `scale` were implemented within `helios.math.transform`. A key decision was to standardize on post-multiplication (M' = M * T) for all transformations, to provide parity with [`glm`](https://github.com/g-truc/glm): This convention ensures that new transformations are applied in the _local space_ of a [model matrix `M`](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-transformations-a-change-of-coordinates-perspective).

  <!--truncate-->

## Implementation Notes: `constexpr` and Performance
To maximize performance and enable compile-time computation, all transformation functions were designed as `constexpr` operations. The notable exception is `rotate()`, which depends on trigonometric functions (`sin`, `cos`) and vector normalization (`sqrt`), none of which are `constexpr` in the standard library. Future work may include implementing `constexpr` variants of these mathematical primitives, depending on how benchmarks fare in specific rendering scenarios.

The `translate` and `scale` functions were implemented as direct, element-wise modifications of the input matrix, avoiding the creation of temporary matrices. This optimized approach is mathematically equivalent to the full matrix multiplication but results in more efficient code.

On to the rendering pipeline!

<SocialLinks />
