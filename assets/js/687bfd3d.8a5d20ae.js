"use strict";(self.webpackChunkgaragecraft_games=self.webpackChunkgaragecraft_games||[]).push([[4357],{8075:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2025/09/14/updates-to-main","metadata":{"permalink":"/devlog/2025/09/14/updates-to-main","source":"@site/devlog/2025-09-14-updates-to-main/index.mdx","title":"Updates to main()","description":"In the spirit of yesterday\'s refactoring efforts...","date":"2025-09-14T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":0.88,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Updates to main()","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","linear algebra","computer graphics","indiegames"]},"unlisted":false,"nextItem":{"title":"The Great Modular Restructuring","permalink":"/devlog/2025/09/13/the-great-modular-restructuring"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### In the spirit of yesterday\'s refactoring efforts...\\n\\n`main()` serves as a great example of [yesterday\'s](/devlog/2025/09/13/the-great-modular-restructuring) restructuring in practice: The `OpenGLDevice` is created, then passed to a `GLFWApplication` which manages window creation and the main loop. The ultimate goal is for the application to own and provide the input system, further simplifying the program\'s entry point and properly encapsulating platform-specific details within the appropriate module.\\n\\n\x3c!--truncate--\x3e\\n\\n\\n```cpp\\nint main() {\\n    // 1. create the rendering device\\n    const auto opengl = std::make_unique<heliosOpenGl::OpenGLDevice>();\\n    // 2. create the config for the main window\\n    auto cfg = heliosGLFWUtil::GLFWFactory::makeWindowCfg(\\"helios - Simple Cube Renderer\\");\\n\\n    // 3. create the app.\\n    const auto app = heliosGLFWUtil::GLFWFactory::makeApplication(opengl.get());\\n\\n    // 4. create the main window\\n    heliosWinGlfw::GLFWWindow& win = app->createWindow(cfg);\\n\\n    // 5. initialize the app\\n    app->init();\\n    // ... and set focus to the window\\n    app->focus(win);\\n\\n    // get the InputManager\\n    auto& inputManager = app->inputManager();\\n\\n    while (!win.shouldClose()) {\\n        inputManager.tick(0.0f);\\n\\n        if (inputManager.isKeyPressed(heliosInput::Key::ESC)) {\\n            std::cout << \\"Key Pressed [ESC]\\" << std::endl;\\n        }\\n\\n        win.swapBuffers();\\n    }\\n\\n    return EXIT_SUCCESS;\\n}\\n```\\n\\n\\n\\n\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/13/the-great-modular-restructuring","metadata":{"permalink":"/devlog/2025/09/13/the-great-modular-restructuring","source":"@site/devlog/2025-09-13-the-great-modular-restructuring/index.mdx","title":"The Great Modular Restructuring","description":"Subsystems, subsystems, subsystems!","date":"2025-09-13T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":1.48,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"The Great Modular Restructuring","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","linear algebra","computer graphics","indiegames"]},"unlisted":false,"prevItem":{"title":"Updates to main()","permalink":"/devlog/2025/09/14/updates-to-main"},"nextItem":{"title":"Layer Abstraction initiated","permalink":"/devlog/2025/09/07/layer-abstraction has-begun"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### Subsystems, subsystems, subsystems!\\n\\nThe last few days have seen some restructuring in the [helios codebase](https://github.com/garagecraft-games/helios), with namespaces and modules being reorganized. This was mainly driven by a clearer definition of responsibilities for individual classes, which can now be better refined as the implementation progresses.\\n\\n\x3c!--truncate--\x3e\\n\\n As requirements grow, the responsibilities of each module become more apparent, which also influences the abstractions. Encapsulating third-party libraries like [GLFW](https://www.glfw.org/) and providing low-level access to their functions focuses attention more sharply on the demands of a flexible architecture.\\n\\nPointer and reference handling in C++ still feels a bit unfamiliar coming from higher-level languages. This is where you realize how much manual work Java(\'s garbage collector) saves you from. Every allocation in C++ becomes a conscious decision, every object lifetime a deliberate design choice.\\n\\n```cpp\\nint main() {\\n\\n    const auto opengl = std::make_unique<heliosOpenGl::OpenGLDevice>();\\n\\n    const auto app = std::make_unique<heliosGlfw::GLFWApplication>(opengl.get());\\n    auto cfg = heliosGlfw::GLFWWindowConfig{};\\n    cfg.title = \\"helios - Simple Cube Renderer\\";\\n    cfg.frameBufferSizeCallback = [](GLFWwindow* win, const int width, const int height) {\\n        glViewport(0, 0, width, height);\\n    };\\n\\n    heliosGlfw::GLFWWindow& win = app->createWindow(cfg);\\n    app->init();\\n\\n    // move this to the application\\n    auto glfwInput = std::make_unique<heliosInput::glfw::GLFWInput>();\\n    std::unique_ptr<heliosInput::core::InputAdapter> input = std::move(glfwInput);\\n    heliosInput::InputManager inputManager{std::move(input)};\\n\\n    while (!win.shouldClose()) {\\n        if (inputManager.isKeyPressed(heliosInput::Key::ESC, win)) {\\n            std::cout << \\"Key Pressed [ESC]\\" << std::endl;\\n        }\\n\\n        win.swapBuffers().pollEvents();\\n    }\\n\\n    return EXIT_SUCCESS;\\n}\\n```\\n\\nAs I work more with this language, it becomes clear why it remains the industry standard for game development instead of Java or other managed languages. The control you get over memory layout, allocation patterns and performance characteristics is the difference between establishing stable frame times and dealing with unpredictable garbage collection pauses.\\n\\n\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/07/layer-abstraction has-begun","metadata":{"permalink":"/devlog/2025/09/07/layer-abstraction has-begun","source":"@site/devlog/2025-09-07-layer-abstraction has-begun/index.mdx","title":"Layer Abstraction initiated","description":"This time, there will be no Feature Creep - I promise!","date":"2025-09-07T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":0.98,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Layer Abstraction initiated","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","linear algebra","computer graphics","indiegames"]},"unlisted":false,"prevItem":{"title":"The Great Modular Restructuring","permalink":"/devlog/2025/09/13/the-great-modular-restructuring"},"nextItem":{"title":"Inb4 Clip Space ","permalink":"/devlog/2025/09/05/inbefore-clipspace"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### This time, there will be no Feature Creep - I promise!\\n\\nFrom `Vertex` to `MeshData` to device-specific `Meshes` - over the weekend, I took a sidestep from the math lib to focus on the architectural planning and development of the underlying rendering layer, accompanied by the scene layer that is responsible for abstracting scene graphs away from the actual rendering process.\\n\\n\x3c!--truncate--\x3e\\n\\n### Testing and Examples Subsystem\\nOne of the more important tasks was to establish a proper testing infrastructure. `glm` integration provides both robust math functionality and reference implementations for testing. Additionally, I\'ve added an examples subsystem, complete with `GLFW` windowing and `glad` OpenGL context management.\\n\\n### Game Programming as Enterprise Software Development?\\nI\'m well aware that the true test isn\'t whether `helios` can render a perfect triangle in isolation, but whether these early architectural decisions will hold up when handling the complex and dynamic scenes that real applications demand. In software architecture, a well-laid-out plan is fundamental. And, as I know from my time as a senior full-stack dev, the deepest insights come not just from understanding the domain, but - from an engineering perspective - from refactoring.\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/05/inbefore-clipspace","metadata":{"permalink":"/devlog/2025/09/05/inbefore-clipspace","source":"@site/devlog/2025-09-05-inbefore-clipspace/index.mdx","title":"Inb4 Clip Space ","description":"Updates from the commit log","date":"2025-09-05T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":1.3,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Inb4 Clip Space ","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","linear algebra","computer graphics","indiegames"]},"unlisted":false,"prevItem":{"title":"Layer Abstraction initiated","permalink":"/devlog/2025/09/07/layer-abstraction has-begun"},"nextItem":{"title":"Model Matrix: Rotations","permalink":"/devlog/2025/09/02/model-matrix-rotations"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### Updates from the commit log\\n\\n`helios` now implements core vector operations, including subtraction for directional calculations, dot product for scalar projections, and cross product for normal vector computation and creating orthonormal bases, respectively. The cross product implementation utilizes `constexpr` specifications for compile-time evaluation when operands are constant expressions.\\nThe `lookAt` function constructs view matrices for camera-space transformations following [standard computer graphics methodology](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/change-of-coordinates-and-applications-to-view-matrices). The implementation creates an orthonormal basis from `eye`, `target`, and `up` vectors, then formulates the change-of-basis matrix with integrated translation components for camera positioning to the origin.\\n\\n\x3c!--truncate--\x3e\\n\\n### Performance and Technical Considerations\\nBenchmarking was implemented for the cross product and `lookAt` functions due to their frequent invocation in rendering contexts.\\nThe results validate the effectiveness of `constexpr` optimizations, but I\'m not close to `glm` in this regard, as their optimizations go several steps further than helios\' userland code implementation.\\n\\n| Benchmark | Time | CPU | Iterations |\\n|-----------|------|-----|------------|\\n| BM_vec3Constructor/real_time | 5.04 ns | 4.89 ns | 127,890,789 |\\n| BM_glm_vec3Constructor/real_time | 4.25 ns | 4.07 ns | 161,100,528 |\\n| BM_vec3Cross/real_time | 20.1 ns | 19.7 ns | 34,872,072 |\\n| BM_glm_vec3Cross/real_time | 7.28 ns | 7.29 ns | 94,326,910 |\\n| BM_vec3Dot/real_time | 12.2 ns | 11.8 ns | 57,045,623 |\\n| BM_glm_vec3Dot/real_time | 10.1 ns | 9.81 ns | 70,071,613 |\\n\\n### Static\\nSome symbol collisions from duplicate test function definitions happened during compilation. I remembered from C that `static` limits symbol scope to file level, which resolved the issue without further changes - it\'s always nice when simple concepts provide quick solutions without requiring the introduction of new namespaces.\\n\\n<SocialLinks />"},{"id":"/2025/09/02/model-matrix-rotations","metadata":{"permalink":"/devlog/2025/09/02/model-matrix-rotations","source":"@site/devlog/2025-09-02-model-matrix-rotations/index.mdx","title":"Model Matrix: Rotations","description":"As a follow-up to my article on Model Matrices, which describes the connection to change-of-coordinates matrices, I\'ve found the time to revisit the topic. I\'ve written a new article about matrix composition in the context of the Model and Rotation matrices to highlight the algebraic foundations.","date":"2025-09-02T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":0.97,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Model Matrix: Rotations","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","linear algebra","computer graphics","indiegames"]},"unlisted":false,"prevItem":{"title":"Inb4 Clip Space ","permalink":"/devlog/2025/09/05/inbefore-clipspace"},"nextItem":{"title":"Establishing the Transformation Library","permalink":"/devlog/2025/08/31/establishing-the-transformation-library"}},"content":"import RotationComposition from \\"./img/rotationcomposition.gif\\";\\nimport {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n<center>\\n<img style={{mixBlendMode:\\"screen\\",filter:\\"invert(1)\\"}} src={RotationComposition} />\\n</center>\\nAs a follow-up to [my article on Model Matrices](/devlog/2025/08/26/model-matrix-transformations), which describes the connection to change-of-coordinates matrices, I\'ve found the time to revisit the topic. I\'ve written a [new article](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-rotation-world-vs-local-origin) about matrix composition in the context of the Model and Rotation matrices to highlight the algebraic foundations.\\n\\n \x3c!--truncate--\x3e\\n\\nIn the article, I explore the difference between rotating an object around its own center (local space) and rotating it around an external point in the game world (world space). I show why the order of matrix multiplication is so important and how you can significantly improve performance by pre-calculating the transformation matrix. And since I use glm as a reference for my own implementation, I also cover how rotations are handled in that library (and in Unity).\\n\\nYou can read the article [here](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-rotation-world-vs-local-origin).\\n\\n\\n<SocialLinks />"},{"id":"/2025/08/31/establishing-the-transformation-library","metadata":{"permalink":"/devlog/2025/08/31/establishing-the-transformation-library","source":"@site/devlog/2025-08-31-establishing-the-transformation-library/index.mdx","title":"Establishing the Transformation Library","description":"This weekend\'s development on the helios engine centered on finalizing transformation logic within helios.math.","date":"2025-08-31T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":1.05,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Establishing the Transformation Library","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","linear algebra","computer graphics","indiegames"]},"unlisted":false,"prevItem":{"title":"Model Matrix: Rotations","permalink":"/devlog/2025/09/02/model-matrix-rotations"},"nextItem":{"title":"Model Matrix: Transformations","permalink":"/devlog/2025/08/26/model-matrix-transformations"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nThis weekend\'s development on the [helios engine](/helios) centered on finalizing transformation logic within [`helios.math`](https://github.com/ThorstenSuckow/helios/tree/main/src/helios/math).\\n\\nThe transformation functions `translate`, `rotate`, `scale` were implemented within `helios.math.transform`. A key decision was to standardize on post-multiplication (M\' = M * T) for all transformations, to provide parity with [`glm`](https://github.com/g-truc/glm): This convention ensures that new transformations are applied in the _local space_ of a [model matrix `M`](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-transformations-a-change-of-coordinates-perspective).\\n\\n  \x3c!--truncate--\x3e\\n\\n## Implementation Notes: `constexpr` and Performance\\nTo maximize performance and enable compile-time computation, all transformation functions were designed as `constexpr` operations. The notable exception is `rotate()`, which depends on trigonometric functions (`sin`, `cos`) and vector normalization (`sqrt`), none of which are `constexpr` in the standard library. Future work may include implementing `constexpr` variants of these mathematical primitives, depending on how benchmarks fare in specific rendering scenarios.\\n\\nThe `translate` and `scale` functions were implemented as direct, element-wise modifications of the input matrix, avoiding the creation of temporary matrices. This optimized approach is mathematically equivalent to the full matrix multiplication but results in more efficient code.\\n\\nOn to the rendering pipeline!\\n\\n<SocialLinks />"},{"id":"/2025/08/26/model-matrix-transformations","metadata":{"permalink":"/devlog/2025/08/26/model-matrix-transformations","source":"@site/devlog/2025-08-26-model-matrix-transformations/index.mdx","title":"Model Matrix: Transformations","description":"As I was working on porting the rotation matrices for the helios.math.transform library, I took a detour to formalize the underlying linear algebra. My goal was to move beyond treating the rotational part of the model matrix as just a black box and instead understand it from a coordinate system perspective.","date":"2025-08-26T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":0.63,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Model Matrix: Transformations","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","linear algebra","computer graphics","indiegames"]},"unlisted":false,"prevItem":{"title":"Establishing the Transformation Library","permalink":"/devlog/2025/08/31/establishing-the-transformation-library"},"nextItem":{"title":"CMake has entered the chat","permalink":"/devlog/2025/08/23/cmake-has-entered-the-chat"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nAs I was working on porting the rotation matrices for the `helios.math.transform` library, I took a detour to formalize the underlying linear algebra. My goal was to move beyond treating the rotational part of the model matrix as just a black box and instead understand it from a coordinate system perspective.\\n\\n \x3c!--truncate--\x3e\\n\\n This led me to writing an article that derives the model matrix as a change-of-coordinates transformation and proves the equivalence between pre-rotating the matrix and post-rotating the transformed vector. If you\'re interested in the mathematical foundations of these essential transformations, you can [read the full derivation here](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-transformations-a-change-of-coordinates-perspective).\\n\\n<SocialLinks />"},{"id":"/2025/08/23/cmake-has-entered-the-chat","metadata":{"permalink":"/devlog/2025/08/23/cmake-has-entered-the-chat","source":"@site/devlog/2025-08-23-cmake-has-entered-the-chat/index.mdx","title":"CMake has entered the chat","description":"Over the weekend, I focused on refactoring mat4 and vec3. Additionally, I\'ve made some adjustments to my toolset.","date":"2025-08-23T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":2.1,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"CMake has entered the chat","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","programming","benchmarking","cmake","backseatcoding","indiegames"]},"unlisted":false,"prevItem":{"title":"Model Matrix: Transformations","permalink":"/devlog/2025/08/26/model-matrix-transformations"},"nextItem":{"title":"Sundays are for constexpr","permalink":"/devlog/2025/08/17/helios-engine-foundation"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nOver the weekend, I focused on refactoring mat4 and vec3. Additionally, I\'ve made some adjustments to my toolset.\\n\\n\x3c!--truncate--\x3e\\n\\n## Refactoring and Benchmarking: helios.math.core\\nI took the time to refactor  `vec3` and `mat4` into `helios.math.core`.\\n\\nBy isolating these (and some more) core components, I hope to ensure a more fine grained _separation of concerns_ right from the beginning. I also depend now on [Google Benchmark](https://github.com/google/benchmark) and put `mat4` to the test:\\nSurely, the power house in OpenGL mathematics is [GLM](https://github.com/g-truc/glm) (OpenGL Mathematics  library), which I frequently use. However, to get a hang of C++ I decided to implement some of the (basic) requirements myself.\\n\\nHere\'s a look at the numbers:\\n\\n<center>\\n![](img/benchmark_mat4.png)\\n</center>\\n\\nIn both constructor and multiplication tests, the helios implementation shows a promising performance. Of course I\'m nowhere close to the optimizations of glm which sports much, much more functionality than my basic implementations, but its nonetheless nice to see how the two compare.\\n\\n### Benchmarking Guid Pointer To Implementation\\n\\nRemember my bold claim about the[performance drawbacks of pointer-to-implementation and heap allocation](/devlog/2025/08/17/helios-engine-foundation)? I\u2019ve put together a benchmark [here](https://github.com/garagecraft-games/helios/blob/main/benchmarks/helios/util/Guid.benchmark.cpp), comparing the regular and PIMPL versions. As expected, the latter comes with a noticeable performance hit:\\n\\n\\n| Benchmark                        | Time| Time (CPU) | Iterations |\\n|----------------------------------|------------------|------------|------------|\\n| BM_GuidGenerate                  | 8.70 ns          | 8.40 ns    | 83,743,377 |\\n| BM_GuidPimplGenerate             | 92.3 ns          | 92.7 ns    | 7,920,792  |\\n\\n\\n## A New Workflow: CLion and CMake\\nI\u2019m parting ways with MSVS (for now) in favor of a more automated, cross-platform workflow with [CLion](https://www.jetbrains.com/clion/) and [CMake](https://cmake.org). The goal is to let modern tooling take care of the heavy lifting, especially with dependency management: It turned out that incorporating Google Benchmark was too much of a hassle (for me at last), but CMake did the trick in no time. I also feel pretty much right at home coming from [composer](https://getcomposer.org), [packagist](https://packagist.org) and [npm](https://www.npmjs.com).\\n\\n\\n<center>\\n![](img/screenshot.png)\\n</center>\\n\\n\\nIt wasn\'t without its challenges, and I\'m still navigating the learning curve, but the potential benefits in productivity and project maintainability are promising.\\n\\n## Join Me on the Journey\\nI streamed this entire process live on [Twitch](https://www.twitch.tv/garagecraft_games). If you want to see the code, the benchmarks, and the occasional head-scratching moment as I stumbled through the new CMake setup, you can [catch the VOD here](https://youtube.com/live/FKKh15M_bzY).\\n\\n<SocialLinks />"},{"id":"/2025/08/17/helios-engine-foundation","metadata":{"permalink":"/devlog/2025/08/17/helios-engine-foundation","source":"@site/devlog/2025-08-17-helios-engine-foundation/index.md","title":"Sundays are for constexpr","description":"For a game engine, the first step isn\u2019t rendering a scene or simulating complex physics - it\u2019s laying the foundational bricks. This weekend, I ~eased~ dove headfirst into that foundation for my personal C++ engine project, Helios, and it was a fantastic journey through the nuances of modern C++ design.","date":"2025-08-17T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":2.75,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Sundays are for constexpr","tags":["devlog","helios"]},"unlisted":false,"prevItem":{"title":"CMake has entered the chat","permalink":"/devlog/2025/08/23/cmake-has-entered-the-chat"},"nextItem":{"title":"Lost in Translation","permalink":"/devlog/2025/08/16/lost-in-translation"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n\\nFor a game engine, the first step isn\u2019t rendering a scene or simulating complex physics - it\u2019s laying the foundational bricks. This weekend, I ~eased~ dove headfirst into that foundation for my personal C++ engine project, *Helios*, and it was a fantastic journey through the nuances of modern C++ design.\\n\\n\x3c!--truncate--\x3e\\n\\n\\n### Starting with a Clean Slate: C++20 Modules\\nFrom the beginning, I decided to build Helios on a modern footing, which meant embracing C++20 modules. Leaving the legacy of `#include` behind, explicit dependency graphs with `import` and `export` are the goal. Solving a few issues solidified a key lesson: with modules, build scripts are as much a part of your architecture as your C++ code (even though the prospect of a legacy audit makes me a little nervous) .\\n\\n### The `vec3` Story: More Than Just Three Floats\\nThe first real piece of the engine was the humble `vec3`. Sounds simple, right? Yet it became the perfect canvas for exploring modern C++ features. The goal wasn\'t just to make it work, but to make it efficient, so that hundreds operations in between frames can be run in the shortest time possible.\\n\\nI wrapped my head around [`constexpr`](https://en.cppreference.com/w/cpp/language/constexpr.html), amongst others, and used it where applicable: constructors, the `operator[]`, and other accessors were all designed to be usable at compile time, which allows for defining constant vectors like world axes or colors that are baked directly into the program, with zero runtime cost[^static_assert].\\n\\n[^static_assert]: It also enables compile-time validation with [`static_assert`](https://en.cppreference.com/w/cpp/language/static_assert.html), catching bugs before the code even runs.\\n\\n### The Guid Lesson: Choosing the Right Tool\\nNext up was a system for unique object identification. My first instinct for the [`Guid` class](https://github.com/garagecraft-games/helios/blob/main/src/helios/util/Guid.cpp) was to hide the implementation details using the **Pimpl idiom** (_Pointer to Implementation_)[^pimpl]. It\u2019s a classic pattern for reducing compile-time dependencies.\\n\\n[^pimpl]: See https://en.wikipedia.org/wiki/Opaque_pointer (retrieved 17.08.2025)\\n\\nWell, as much as I like the concept behind the [Bridge Pattern](https://en.wikipedia.org/wiki/Bridge_pattern) and its usage in C++, it was completely the wrong tool for this job: Due to the way the memory is allocated for the referenced data structure (additional heap-allocation for every `Guid` that gets created) and due to the fact that a [pointer indirection](https://www.it.uc3m.es/pbasanta/asng/course_notes/pointers_indirection_with_pointers_en.html) for every single `Guid` would be incurred. For a scene graph with many identifiable nodes, this would impose avoidable performance overhead.\\n\\nI scrapped the Pimpl (heh!) and rebuilt Guid as a simple, efficient class wrapping a `uint64_t`. It should be as cheap to use as an `int` - benchmarks tba.\\n\\n<center>\\n![](img/guid.png)\\n</center>\\n\\n### What\'s Next?\\nThe foundation is now in place. I\'m striving for a small math and utility library before I go back to rendering and OpenGL. The process has been a deep dive into not just how C++ features work, but why they are designed the way they are.\\n\\nThe next step is to build on these bricks - to create a scene graph, a Node aggregate, and begin tackling the renderer itself. But I\'ll do so with the confidence that the code it all rests is solid - and, more important - maintainable.\\n\\n----------------"},{"id":"/2025/08/16/lost-in-translation","metadata":{"permalink":"/devlog/2025/08/16/lost-in-translation","source":"@site/devlog/2025-08-16-lost-in-translation/index.md","title":"Lost in Translation","description":"My background is in the web world - I\'ve spent years wrangling Java, JavaScript (and countless frameworks based on it), PHP (from Zend to Laravel over Symfony and self-written solution), and the closest I ever got to the metal was writing C, of which I thought it would give me a head start for a game engine project. In a way, it did: I wasn\'t scared of pointers. But it also gave me a false sense of security.","date":"2025-08-16T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":1.11,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Lost in Translation","tags":["devlog","helios"]},"unlisted":false,"prevItem":{"title":"Sundays are for constexpr","permalink":"/devlog/2025/08/17/helios-engine-foundation"},"nextItem":{"title":"Hello World","permalink":"/devlog/2025/08/15/hello-world"}},"content":"My background is in the web world - I\'ve spent years wrangling Java, JavaScript (and countless frameworks based on it), PHP (from Zend to Laravel over Symfony and self-written solution), and the closest I ever got to the metal was writing C, of which I thought it would give me a head start for a game engine project. In a way, it did: I wasn\'t scared of pointers. But it also gave me a false sense of security.\\n\\n\x3c!--truncate--\x3e\\n\\nMoving to C++ is like a profound culture shock. The language demands a completely different level of discipline. Suddenly, it\'s not just about maintaining memory, it\'s also about ownership. The concept of smart pointers, and the critical role of a destructor is a universe away from the cozy safety of a [garbage collector \u2764\ufe0f](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html) or `==` out of the box. (I now understand the motivation behind Java better.)\\n\\nAnd that\'s before you even get to the build process: No more _save and refresh_ and _hot reloads_. Here, you enter a three-act play with the compiler, the linker, and a mysterious director named VisualStudio 2022 and its ever so confusing tree menus and option dialogs. I guess it\'s time to get familiar with compiler command line options, since they play such a crucial role in C++..."},{"id":"/2025/08/15/hello-world","metadata":{"permalink":"/devlog/2025/08/15/hello-world","source":"@site/devlog/2025-08-15-hello-world/index.mdx","title":"Hello World","description":"Hi everyone!","date":"2025-08-15T00:00:00.000Z","tags":[{"inline":true,"label":"devlog","permalink":"/devlog/tags/devlog"},{"inline":true,"label":"helios","permalink":"/devlog/tags/helios"}],"readingTime":1.46,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Hello World","tags":["devlog","helios"]},"unlisted":false,"prevItem":{"title":"Lost in Translation","permalink":"/devlog/2025/08/16/lost-in-translation"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n\\n<center>\\n![](img/adventofcode2415.gif)\\n</center>\\n\\nHi everyone!\\n\\nFor years, my world has been one of [software architecture and senior-level development](https://www.linkedin.com/in/thorstensuckow/), mainly focusing on integration of frontend systems into large scale web applications. I\u2019ve designed systems, worked with teams of various sizes, and treated software development as a true [craft](https://thorsten.suckow-homberg.de/docs/articles/software-craftsmanship). But sometimes, a single problem can change your entire perspective. For me, that was [Day 15 of Advent of Code in 2024](https://adventofcode.com/2024/day/15).\\n\\n\x3c!--truncate--\x3e\\n\\nThat little warehouse robot (pictured above) navigating a 2D grid wasn\u2019t just another puzzle. It was the final push, the moment that solidified a long-brewing passion: It made me decide to dive into the world of game development.\\n\\nAs a software developer, I\'m captivated by the interplay of design, modular components, optimization, and the final polish that turns code into a seamless experience. Game development feels like a very special expression of this craft: It\u2019s a field where the formal elegance of linear algebra directly creates the visual magic of computer graphics, where every line of code contributes to an interactive world.\\n\\nIt\u2019s the perfect fusion of technical challenge and creative artistry. This is why I\'m starting [garagecraft games](/).\\n\\ngaragecraft games is more than just a label: It\u2019s a philosophy. It\u2019s about embracing the hobbyist spirit, the joy of building something from the ground up, and celebrating the art of software craftsmanship in a different medium. A creative space to explore, learn, and share game development.\\n\\nI hope you\u2019ll follow along, and even more so, I look forward to the day we can all jump into a game session together.\\n\\n <SocialLinks />\\n\\nLet the journey begin,\\n\\nThorsten."}]}}')}}]);