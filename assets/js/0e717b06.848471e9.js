"use strict";(self.webpackChunkgaragecraft_games=self.webpackChunkgaragecraft_games||[]).push([[7407],{1470:(e,n,t)=>{t.d(n,{A:()=>y});var a=t(6540),r=t(4164),s=t(3104),i=t(6347),o=t(205),d=t(7485),l=t(1682),u=t(679);function c(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,a.useMemo)(()=>{const e=n??function(e){return c(e).map(({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a}))}(t);return function(e){const n=(0,l.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function h({value:e,tabValues:n}){return n.some(n=>n.value===e)}function f({queryString:e=!1,groupId:n}){const t=(0,i.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(r),(0,a.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})},[r,t])]}function p(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,s=m(e),[i,d]=(0,a.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s})),[l,c]=f({queryString:t,groupId:r}),[p,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,u.Dv)(n);return[t,(0,a.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),b=(()=>{const e=l??p;return h({value:e,tabValues:s})?e:null})();(0,o.A)(()=>{b&&d(b)},[b]);return{selectedValue:i,selectValue:(0,a.useCallback)(e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);d(e),c(e),g(e)},[c,g,s]),tabValues:s}}var g=t(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(4848);function w({className:e,block:n,selectedValue:t,selectValue:a,tabValues:i}){const o=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.a_)(),l=e=>{const n=e.currentTarget,r=o.indexOf(n),s=i[r].value;s!==t&&(d(n),a(s))},u=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:i.map(({value:e,label:n,attributes:a})=>(0,v.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:u,onClick:l,...a,className:(0,r.A)("tabs__item",b.tabItem,a?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function x({lazy:e,children:n,selectedValue:t}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===t);return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function j(e){const n=p(e);return(0,v.jsxs)("div",{className:(0,r.A)("tabs-container",b.tabList),children:[(0,v.jsx)(w,{...n,...e}),(0,v.jsx)(x,{...n,...e})]})}function y(e){const n=(0,g.A)();return(0,v.jsx)(j,{...e,children:c(e.children)},String(n))}},6378:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>a,toc:()=>c});var a=t(6393),r=t(4848),s=t(8453),i=t(1470),o=t(9365);const d={title:"helios - A High-Level Overview of the Game Loop Architecture",description:"A deep dive into the architectural separation of concerns in helios. This post outlines how deterministic world mutations are handled via bare-metal Commands and Managers, while decoupled communication relies on a mix of double-buffered and immediate Event Buses to ensure both thread safety and low-latency feedback.",date:"2026-01-05",slug:"/2026-01-05-high-level-overview-of-the-game-loop-architecture/",tags:["devlog","helios","architecture","game-loop","events","commands","double-buffering","data-oriented-design"],keywords:["cpp","game engine","architecture","command pattern","event bus","immediate mode","batch processing","determinism","frame lifecycle"],authors:["thorstensuckow"]},l=void 0,u={authorsImageUrls:[void 0]},c=[{value:"High-Level Overview of the Game Loop Architecture",id:"high-level-overview-of-the-game-loop-architecture",level:2},{value:"Commands and CommandBuffer",id:"commands-and-commandbuffer",level:2},{value:"Events and double-buffered EventBus",id:"events-and-double-buffered-eventbus",level:2},{value:"Optional manager-based command processing",id:"optional-manager-based-command-processing",level:3},{value:"Immediate Events (single-buffered)",id:"immediate-events-single-buffered",level:2},{value:"Commands und CommandBuffer",id:"commands-und-commandbuffer",level:2},{value:"Events und Double-Buffered EventBus",id:"events-und-double-buffered-eventbus",level:2},{value:"Optionale Manager-basierte Command-Verarbeitung",id:"optionale-manager-basierte-command-verarbeitung",level:3},{value:"Immediate Events (Single-Buffered)",id:"immediate-events-single-buffered-1",level:2}];function m(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Over the past few weeks, I\u2019ve been busy refining the helios GameLoop to enable player interactions with various GameObjects. This included, in particular, controlling the player ship, spawning enemies, and - the holy grail of every game - the collision system."}),"\n",(0,r.jsx)(n.p,{children:"It quickly became apparent that a purely object-oriented approach was too brittle and inflexible, leaving me no choice but to read up on a more versatile approach: the component-based system. For me, as an OOP scholar, this meant a paradigm shift in how I design software - but it was worth it."}),"\n",(0,r.jsx)(n.p,{children:"And I\u2019ve come to feel strongly that academic teaching places far too much emphasis on OOP."}),"\n",(0,r.jsx)(n.p,{children:"Even though I am only scratching the surface of proper ECS in this prototype phase, I am very satisfied with the result. However, the problem remained of how to communicate and process cross-frame actions - who orchestrates the spawning? What is a spawn, anyway? Is it an Event? Is it a Command?"}),"\n",(0,r.jsx)(n.p,{children:"Based on the collision system, I had to turn the architectural screw a little further - resulting in the following design, which I will be pouring into the framework over the coming weeks."}),"\n",(0,r.jsx)(n.h2,{id:"high-level-overview-of-the-game-loop-architecture",children:"High-Level Overview of the Game Loop Architecture"}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsxs)(o.A,{value:"[english]",children:[(0,r.jsxs)(n.p,{children:["helios distinguishes between ",(0,r.jsx)(n.strong,{children:"Commands"})," (world-mutating operations) and ",(0,r.jsx)(n.strong,{children:"Events"})," (signals/facts).\nCommands exist to mutate the world state ",(0,r.jsx)(n.em,{children:"deterministically"}),". Events exist to decouple systems: they either express a request/intent (e.g. SpawnRequest) or a fact (e.g. ",(0,r.jsx)(n.code,{children:"SolidCollisionEvent"}),", ",(0,r.jsx)(n.code,{children:"TriggerCollisionEvent"}),", ",(0,r.jsx)(n.code,{children:"SpawnedEvent"}),")."]}),(0,r.jsx)(n.h2,{id:"commands-and-commandbuffer",children:"Commands and CommandBuffer"}),(0,r.jsxs)(n.p,{children:["Participating systems can write Commands into the CommandBuffer in frame $N$.\nAt the beginning of each frame $N+1$, the CommandBuffer is flushed, which commits the Commands - i.e. their ",(0,r.jsx)(n.code,{children:"execute()"})," method is invoked. This method contains the logic that mutates the world state (e.g. spawning, despawning, health changes, component changes). Commands are ",(0,r.jsx)(n.code,{children:"bare metal"})," and therefore the lowest level in the game-loop layer, i.e. no further preparation of a Command is required. The system should therefore also be able to commit Commands coming directly from a developer console into the GameWorld (optionally delegating them to their respective managers - see below)."]}),(0,r.jsx)(n.h2,{id:"events-and-double-buffered-eventbus",children:"Events and double-buffered EventBus"}),(0,r.jsxs)(n.p,{children:["In addition, systems can emit Events in frame $N$, e.g. ",(0,r.jsx)(n.strong,{children:"request events"})," - events that intend to mutate the world state - or plain signals such as ",(0,r.jsx)(n.code,{children:"SolidCollisionEvent"}),", from which world-mutating Commands (despawn) can be derived.\nThe EventBus is double-buffered (",(0,r.jsx)(n.code,{children:"helios.core.data.TypeIndexedDoubleBuffer"}),"): events are written into the write buffer in frame $N$ and become visible in the read buffer only after a buffer swap (",(0,r.jsx)(n.code,{children:"swapBuffers()"}),") at the beginning of frame $N+1$."]}),(0,r.jsx)(n.p,{children:"At the beginning of frame $N+1$, events are dispatched from the read buffer. As mentioned above, request events can be translated into Commands and written into the CommandBuffer."}),(0,r.jsx)(n.p,{children:"This yields the following order at the beginning of frame $N+1$:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"EventBus.swapBuffers()\n\nEventBus.dispatch() // Events from which Commands may be generated\n\nCommandBuffer.flush() // Commit - mutates the world state,\n                      // optional manager-based command processing\n"})}),(0,r.jsx)(n.h3,{id:"optional-manager-based-command-processing",children:"Optional manager-based command processing"}),(0,r.jsxs)(n.p,{children:["Instead of having each Command fully implement the mutation logic in ",(0,r.jsx)(n.code,{children:"execute()"}),", the CommandBuffer can additionally hold registered managers. In this model, ",(0,r.jsx)(n.code,{children:"execute()"})," primarily performs a registering/planning step, and the managers then process their work as a coordinated batch."]}),(0,r.jsx)(n.p,{children:"Example:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"CommandBuffer::flush() {\n    for (auto& cmd : commands)\n        cmd->execute();   // in execute e.g.:\n                          // spawnManager->enqueue(position, enemyType);\n\n    for (auto& mgr : managers)\n        mgr->process();   // the spawnManager processes the spawn list\n}\n"})}),(0,r.jsx)(n.p,{children:"This model allows Commands to be bundled, sorted, and processed deterministically (e.g. handle all spawns first, then all despawns)."}),(0,r.jsx)(n.h2,{id:"immediate-events-single-buffered",children:"Immediate Events (single-buffered)"}),(0,r.jsxs)(n.p,{children:["For time-critical feedback that does not mutate the world state (particle effects, audio feedback), there is a separate ",(0,r.jsx)(n.strong,{children:"ImmediateBus"})," (single-buffered).\nImmediate events should be processed within the same frame without additional double-buffer latency. A suitable dispatch point is after ",(0,r.jsx)(n.code,{children:"CommandBuffer.flush()"}),', so that feedback can observe the world that was committed at the beginning of the frame in a consistent state. This mitigates latency (e.g. ~16ms at 60fps) and allows feedback to be triggered in the same frame as a specific event, which improves the overall user experience ("game feel").']}),(0,r.jsx)(n.p,{children:"Overall, the frame-begin order becomes:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"EventBus.swapBuffers() // input\nEventBus.dispatch()\n\nCommandBuffer.flush() // mutation\n\nImmediateBus.dispatch() // signals\n\n// gameplay systems updating physics\nMove2DSystem.update();\n...\n"})})]}),(0,r.jsxs)(o.A,{value:"[deutsch]",children:[(0,r.jsxs)(n.p,{children:["helios unterscheidet zwischen ",(0,r.jsx)(n.strong,{children:"Commands"})," (weltver\xe4ndernde Mutationen) und ",(0,r.jsx)(n.strong,{children:"Events"})," (Signale/Fakten).\nCommands dienen dazu, den Weltzustand ",(0,r.jsx)(n.em,{children:"deterministisch"})," zu ver\xe4ndern. Events dienen dazu, Systeme zu entkoppeln: Sie dr\xfccken entweder einen Request/Intent (z. B. SpawnRequest) oder ein Fakt (z. B. ",(0,r.jsx)(n.code,{children:"SolidCollisionEvent"}),", ",(0,r.jsx)(n.code,{children:"TriggerCollisionEvent"}),", ",(0,r.jsx)(n.code,{children:"SpawnedEvent"}),") aus."]}),(0,r.jsx)(n.h2,{id:"commands-und-commandbuffer",children:"Commands und CommandBuffer"}),(0,r.jsxs)(n.p,{children:["Teilnehmende Systeme k\xf6nnen beliebig Commands in Frame $N$ in den CommandBuffer schreiben.\nZu Beginn jedes Frames $N+1$ wird der CommandBuffer geflusht, wodurch die Commands committed werden  - es wird deren ",(0,r.jsx)(n.code,{children:"execute()"}),"-Methode aufgerufen. Die Methode enth\xe4lt die Logik, die den Weltzustand mutiert (z. B. Spawning, Despawning, Health-\xc4nderungen, Component-\xc4nderungen). Commands sind",(0,r.jsx)(n.code,{children:"bare metal"})," und damit die niedrigste Ebene in der GameLoop-Schicht, d.h., es ist keine weitere Aufbereitung eines Commands mehr n\xf6tig. Das System sollte also auch in der Lage sein, Commands von einer Entwickler-Console direkt in die GameWorld zu \xfcbertragen (ggf. an ihre entsprechenden Manager - s.u.)."]}),(0,r.jsx)(n.h2,{id:"events-und-double-buffered-eventbus",children:"Events und Double-Buffered EventBus"}),(0,r.jsxs)(n.p,{children:["Zus\xe4tzlich k\xf6nnen Systeme in Frame $N$ Events erzeugen, z. B. ",(0,r.jsx)(n.strong,{children:"Request Events"})," - solche bspw. die beabsichtigen, einen den Weltzusatend zu mutieren, oder auch einfach nur Signale, wie bspw. ",(0,r.jsx)(n.code,{children:"SolidCollisionEvent"}),", aus der weltzustandmutierende Commands (despawn) abgeleitet werden.\nDer EventBus ist double-buffered (",(0,r.jsx)(n.code,{children:"helios.core.data.TypeIndexedDoubleBuffer"}),"): Events werden in Frame $N$ in den Write-Buffer geschrieben und sind erst nach einem Buffer-Swap (",(0,r.jsx)(n.code,{children:"swapBuffers()"}),") zu Beginn von Frame $N+1$ im Read-Buffer sichtbar."]}),(0,r.jsx)(n.p,{children:"Zu Beginn von Frame N+1 werden die Events aus dem Read-Buffer dispatcht; wie oben bereits erw\xe4hnt, k\xf6nnen dabei aus Request-Events wiederum Commands generiert und in den CommandBuffer geschrieben werden."}),(0,r.jsx)(n.p,{children:"Daraus ergibt sich zu Beginn von Frame $N+1$ die Reihenfolge:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"EventBus.swapBuffers()\n\nEventBus.dispatch() // Events, aus denen ggf. wiederum Commands erzeugt werden\n\nCommandBuffer.flush() // Commit - mutiert den Weltzustand,\n                      // optionale Manager-basierte Command-Verarbeitung\n"})}),(0,r.jsx)(n.h3,{id:"optionale-manager-basierte-command-verarbeitung",children:"Optionale Manager-basierte Command-Verarbeitung"}),(0,r.jsxs)(n.p,{children:["Statt dass jeder Command die Logik einer Mutation vollst\xe4ndig in ",(0,r.jsx)(n.code,{children:"execute()"})," implementiert, kann der CommandBuffer zus\xe4tzlich registrierte Manager besitzen. In diesem Modell f\xfchren Commands in ",(0,r.jsx)(n.code,{children:"execute()"})," prim\xe4r eine registrierende/planende Aktion aus, und die Manager f\xfchren anschlie\xdfend ihre Arbeit koordiniert als Batch aus."]}),(0,r.jsx)(n.p,{children:"Beispiel:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"CommandBuffer::flush() {\n    for (auto& cmd : commands)\n        cmd->execute();   // in execute bspw.:\n                          // spawnManager->enqueue(position, enemyType);\n\n    for (auto& mgr : managers)\n        mgr->process();   // der spawnManager arbeitet die SpawnListe ab\n}\n"})}),(0,r.jsx)(n.p,{children:"Dieses Modell erlaubt es, Commands zu b\xfcndeln, zu sortieren und deterministisch abzuarbeiten (z. B. alle Spawns zusammen, dann alle Despawns)."}),(0,r.jsx)(n.h2,{id:"immediate-events-single-buffered-1",children:"Immediate Events (Single-Buffered)"}),(0,r.jsxs)(n.p,{children:["F\xfcr zeitkritisches Feedback, das nicht den Weltzustand ver\xe4ndert (Partikeleffekte, Audio-Feedback) existiert ein separater ",(0,r.jsx)(n.strong,{children:"ImmediateBus"})," (single-buffered).\nImmediate-Events sollen im selben Frame ohne zus\xe4tzliche Double-Buffer-Latenz verarbeitet werden. Ein geeigneter Dispatch-Punkt ist nach dem ",(0,r.jsx)(n.code,{children:"CommandBuffer.flush()"}),', damit das Feedback die zu Beginn dieses Frames committete Welt konsistent sehen kann. Hierdurch kann Latenz mitigiert werden (bspw. 16ms bei 60fps) und Feedback kann noch im selben Frame zu einem bestimmten Ereignis gegeben werden, was das "Game Feel" verbessern kann.']}),(0,r.jsx)(n.p,{children:"Insgesamt ergibt sich damit zu Frame-Beginn:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"EventBus.swapBuffers() // input\nEventBus.dispatch()\n\nCommandBuffer.flush() // Mutation\n\nImmediateBus.dispatch() // Signale\n\n// gameplay systeme zur aktualisierung der physik\nMove2DSystem.update();\n...\n"})})]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},6393:e=>{e.exports=JSON.parse('{"permalink":"/devlog/2026-01-05-high-level-overview-of-the-game-loop-architecture/","source":"@site/devlog/2026-01-05-high-level-oveview-of-the-game-loop-architecture/index.mdx","title":"helios - A High-Level Overview of the Game Loop Architecture","description":"A deep dive into the architectural separation of concerns in helios. This post outlines how deterministic world mutations are handled via bare-metal Commands and Managers, while decoupled communication relies on a mix of double-buffered and immediate Event Buses to ensure both thread safety and low-latency feedback.","date":"2026-01-05T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"},{"inline":true,"label":"architecture","permalink":"/devlog/tags/architecture"},{"inline":true,"label":"game-loop","permalink":"/devlog/tags/game-loop"},{"inline":true,"label":"events","permalink":"/devlog/tags/events"},{"inline":true,"label":"commands","permalink":"/devlog/tags/commands"},{"inline":true,"label":"double-buffering","permalink":"/devlog/tags/double-buffering"},{"inline":true,"label":"data-oriented-design","permalink":"/devlog/tags/data-oriented-design"}],"readingTime":5.98,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"helios - A High-Level Overview of the Game Loop Architecture","description":"A deep dive into the architectural separation of concerns in helios. This post outlines how deterministic world mutations are handled via bare-metal Commands and Managers, while decoupled communication relies on a mix of double-buffered and immediate Event Buses to ensure both thread safety and low-latency feedback.","date":"2026-01-05","slug":"/2026-01-05-high-level-overview-of-the-game-loop-architecture/","tags":["devlog","helios","architecture","game-loop","events","commands","double-buffering","data-oriented-design"],"keywords":["cpp","game engine","architecture","command pattern","event bus","immediate mode","batch processing","determinism","frame lifecycle"],"authors":["thorstensuckow"]},"unlisted":false,"nextItem":{"title":"New Year\u2019s Eve, New Spawn System","permalink":"/devlog/devlog/2025-12-31-enemy-spawn-system/"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(6540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}},9365:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var a=t(4164);const r={tabItem:"tabItem_Ymn6"};var s=t(4848);function i({children:e,hidden:n,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,t),hidden:n,children:e})}}}]);