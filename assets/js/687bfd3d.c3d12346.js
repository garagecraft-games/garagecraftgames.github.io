"use strict";(self.webpackChunkgaragecraft_games=self.webpackChunkgaragecraft_games||[]).push([[4357],{8075:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2026-02-10-phase-pass-architecture/","metadata":{"permalink":"/devlog/2026-02-10-phase-pass-architecture/","source":"@site/devlog/2026-02-10-gameloop-phase-pass-architecture/index.mdx","title":"Phase/Pass Architecture: Evolution of the Game Loop","description":"A follow-up to the game loop architecture post, introducing the refined Phase/Pass structure. This post explores how helios now organizes the game loop into phases with granular passes, enabling fine-grained control over event propagation and command execution timing.","date":"2026-02-10T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"},{"inline":true,"label":"architecture","permalink":"/devlog/tags/architecture"},{"inline":true,"label":"game-loop","permalink":"/devlog/tags/game-loop"},{"inline":true,"label":"events","permalink":"/devlog/tags/events"},{"inline":true,"label":"commands","permalink":"/devlog/tags/commands"},{"inline":true,"label":"phase-pass","permalink":"/devlog/tags/phase-pass"},{"inline":true,"label":"double-buffering","permalink":"/devlog/tags/double-buffering"},{"inline":true,"label":"data-oriented-design","permalink":"/devlog/tags/data-oriented-design"}],"readingTime":6.21,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Phase/Pass Architecture: Evolution of the Game Loop","description":"A follow-up to the game loop architecture post, introducing the refined Phase/Pass structure. This post explores how helios now organizes the game loop into phases with granular passes, enabling fine-grained control over event propagation and command execution timing.","date":"2026-02-10","slug":"/2026-02-10-phase-pass-architecture/","tags":["devlog","helios","architecture","game-loop","events","commands","phase-pass","double-buffering","data-oriented-design"],"keywords":["cpp","game engine","architecture","command pattern","event bus","phase","pass","commit point","determinism","frame lifecycle"],"authors":["thorstensuckow"]},"unlisted":false,"nextItem":{"title":"helios - A High-Level Overview of the Game Loop Architecture","permalink":"/devlog/2026-01-05-high-level-overview-of-the-game-loop-architecture/"}},"content":"In my [previous post](/devlog/2026-01-05-high-level-overview-of-the-game-loop-architecture/), I outlined the high-level separation between Commands and Events in helios, along with the basic double-buffered EventBus and CommandBuffer concepts. Since then, I\'ve iterated significantly on the architecture, and I\'m excited to share what has emerged: A **Phase/Pass structure** that provides much finer control over when events become visible and when commands execute.\\n\\n\x3c!--truncate--\x3e\\n\\nThe original design worked well for simple scenarios, but as I added more systems, like spawn scheduling, collision response and scene synchronization, I ran into timing issues: Events pushed in one system weren\'t visible to systems that needed to react within the same logical block of processing. So I broke the monolithic frame into hierarchical units.\\n\\n## From Flat to Hierarchical: The Phase/Pass Model\\n\\nThe original architecture treated the frame as a sequence of steps:\\n\\n```cpp\\n// Old approach\\nEventBus.swapBuffers();\\nEventBus.dispatch();\\nCommandBuffer.flush();\\nManagerRepository.flush();\\nImmediateBus.dispatch();\\n// ... systems update ...\\n```\\n\\nThis worked well in simple scenarios, but forced all events to wait until the next frame to be readable - obviously, this approach was rather suboptimal for systems that needed to communicate in the same logical phase.\\n\\nThe new game loop architecture introduces a two-level hierarchy:\\n\\n## Phases and Passes\\n\\nThe game loop is now organized into **Phases** and **Passes**:\\n\\n```\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502                            FRAME                                    \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502                                                                     \u2502\\n\u2502  PRE PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\\n\u2502    Pass 1 (Input) \u2500\u2500> Pass 2 (Commit) \u2500\u2500> Pass 3                    \u2502\\n\u2502                            \u2502                                        \u2502\\n\u2502                     [Pass Commit Point]                             \u2502\\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Phase Commit    \u2502\\n\u2502                                                                     \u2502\\n\u2502  MAIN PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\\n\u2502    Pass 1 (Gameplay) \u2500\u2500> Pass 2 (Collision) \u2500\u2500> Pass 3 (AI)         \u2502\\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Phase Commit    \u2502\\n\u2502                                                                     \u2502\\n\u2502  POST PHASE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\\n\u2502    Pass 1 (Scene Sync) \u2500\u2500> Pass 2 (Cleanup)                         \u2502\\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Phase Commit    \u2502\\n\u2502                                                                     \u2502\\n\u2502                          RENDER                                     \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```\\n\\n**Phases** are divided into three major segments **Pre**, **Main**, **Post**) with distinct responsibilities.\\nAfter each phase, a **Phase Commit** occurs: phase events become readable, pass events are cleared, commands are flushed, and managers process their queues.\\n\\n**Passes** are sub-units within phases. A pass can optionally have a **Commit Point**, making pass-level events readable in subsequent passes of the same phase.\\n\\n## Three Event Buses - Three Scopes\\n\\nThe single EventBus has evolved into three distinct buses, each with a different visibility scope:\\n\\n| Event Bus | Push Method | Read Method | Visibility |\\n|-----------|-------------|-------------|------------|\\n| **Pass** | `pushPass<E>()` | `readPass<E>()` | Subsequent passes (same phase) |\\n| **Phase** | `pushPhase<E>()` | `readPhase<E>()` | Next phase |\\n| **Frame** | `pushFrame<E>()` | `readFrame<E>()` | Next frame |\\n\\nAll buses remain double-buffered, but the **swap timing** is now tied to the appropriate commit point (manual for passes, automatic for phases and frames).\\n\\n### Why Three Buses?\\n\\nConsider collision detection and response:\\n\\n```\\nMAIN PHASE\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 Pass 1: GridCollisionDetectionSystem                                \u2502\\n\u2502   \u2192 Detects projectile-enemy collision                              \u2502\\n\u2502   \u2192 pushPass<TriggerCollisionEvent>(...)                            \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502 [Pass Commit Point]                                                 \u2502\\n\u2502   \u2192 Pass events become readable                                     \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502 Pass 2: ProjectileCollisionSystem                                   \u2502\\n\u2502   \u2192 for (auto& evt : readPass<TriggerCollisionEvent>())             \u2502\\n\u2502   \u2192 Pushes DespawnCommand for projectile                            \u2502\\n\u2502   \u2192 Pushes DamageCommand for enemy                                  \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```\\n\\nWith `pushPass()`, the collision event is visible **within the same phase**. We do not need to wait for the next frame. Instead, it\'s scoped to the phase, so it doesn\'t pollute other phases and allows for generating commands that can be executed in the next phase: `pushPhase()` enables cross-phase communication (e.g., Pre phase schedules spawns, Main phase reads spawn confirmations), and `pushFrame()` handles true cross-frame scenarios like audio triggers.\\n\\n## Fine-Grained Control with Commoit-Points\\n\\nThe key innovation is the **Commit Point**. A pass can declare a commit point, which triggers:\\n\\n1. Pass event bus swap \u2192 events become readable in the same phase\\n2. (Optionally) Structural commit \u2192 commands execute immediately (\u2192 Managers in next pass process Commands)\\n\\n```cpp\\ngameLoop.phase(PhaseType::Pre)\\n    .addPass()\\n    .addSystem<TwinStickInputSystem>(*playerGameObject)\\n    .addCommitPoint(CommitPoint::Structural)  // Move-Commands execute HERE\\n\\n    .addPass()\\n    .addSystem<GameObjectSpawnSystem>(spawnSchedulers)\\n    .addCommitPoint(CommitPoint::Structural)  // New entities active, pass to CommandBuffer\\n                                              // so the underlying SpawnManager can create them\\n\\n    .addPass()\\n    .addSystem<Move2DSystem>();  // Operates on ALL entities\\n```\\n\\nThe `CommitPoint::Structural` variant flushes the CommandBuffer at that point, enabling newly spawned entities to participate in subsequent passes within the same phase.\\n\\n## The Refined Phase Commit\\n\\nAt each phase boundary, the following sequence occurs:\\n\\n```cpp\\n// After each phase completes\\nphaseEventBus.swapBuffers();    // Phase events become readable\\npassEventBus.clearAll();         // Pass events are cleared\\ncommandBuffer.flush();           // Commands execute (mutations)\\ngameWorld.flushManagers();       // Managers process queued requests\\n\\n// Additionally, at the end of Post phase:\\nframeEventBus.swapBuffers();     // Frame events readable in next frame\\n```\\n\\nThis is the evolved version of the original `flush()` sequence, now contextualized within phases.\\n\\n## Complete Frame Execution\\n\\nHere\'s how a complete frame flows:\\n\\n```cpp\\nfor (phase : {Pre, Main, Post}) {\\n\\n    for (pass : phase.passes()) {\\n        for (system : pass.systems()) {\\n            system.update(updateContext);\\n            // Systems can:\\n            // - pushPass<E>() for same-phase communication\\n            // - pushPhase<E>() for next-phase communication\\n            // - pushFrame<E>() for next-frame communication\\n            // - readPass<E>() for events from previous passes\\n            // - readPhase<E>() for events from previous phase\\n            // - readFrame<E>() for events from previous frame\\n        }\\n\\n        if (pass.commitPoint() == CommitPoint::PassEvents) {\\n            passEventBus.swapBuffers();  // Pass events readable\\n        }\\n\\n        if (pass.commitPoint() == CommitPoint::Structural) {\\n            passEventBus.swapBuffers();\\n            commandBuffer.flush();        // Immediate mutation\\n            gameWorld.flushManagers();\\n        }\\n    }\\n\\n    // Phase Commit\\n    phaseEventBus.swapBuffers();    // Phase events readable\\n    passEventBus.clearAll();         // Clear pass events\\n    commandBuffer.flush();           // Execute commands\\n    gameWorld.flushManagers();       // Process manager queues\\n\\n    if (phase == Post) {\\n        frameEventBus.swapBuffers(); // Frame events readable next frame\\n    }\\n}\\n\\nrender();\\n```\\n\\n## Practical Example: Spawning a Projectile\\n\\nLet\'s trace through shooting a projectile:\\n\\n```\\nFrame N\\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\nPRE PHASE\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 Pass 1: TwinStickInputSystem                                        \u2502\\n\u2502   \u2192 Player presses fire button                                      \u2502\\n\u2502   \u2192 Pushes ShootCommand to CommandBuffer                            \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502 [Commit Point: Structural]                                          \u2502\\n\u2502   \u2192 CommandBuffer.flush() executes ShootCommand                     \u2502\\n\u2502   \u2192 SpawnManager creates projectile from pool                       \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502 Pass 2: GameObjectSpawnSystem                                       \u2502\\n\u2502   \u2192 Evaluates spawn rules, schedules enemy spawns                   \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502 [Commit Point: Structural]                                          \u2502\\n\u2502   \u2192 New enemies spawned and activated                               \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502 Pass 3: Move2DSystem, SteeringSystem                                \u2502\\n\u2502   \u2192 All entities (including new projectile) move                    \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```\\n\\nThe projectile exists and moves **in the same frame** it was spawned. In the original architecture, it would have been invisible until frame N+1.\\n\\n## Key Improvements Over the Original Design\\n\\n| Aspect | Original | Phase/Pass |\\n|--------|----------|------------|\\n| Event visibility | Next frame only | Same phase (pass) or next phase |\\n| Command execution | Once per frame | At commit points + phase boundaries |\\n| Structural changes | Wait for next frame | Immediate within phase |\\n| Event scope | Global | Pass / Phase / Frame |\\n| Complexity | Simple | More setup, more control |\\n\\n## When to Use What\\n\\n| Scenario | Use |\\n|----------|-----|\\n| Collision \u2192 Damage response | `pushPass()` + Commit Point |\\n| Spawn request \u2192 Spawn confirmation | `pushPhase()` |\\n| Audio trigger for next frame | `pushFrame()` |\\n| Immediate entity creation | `addCommitPoint(CommitPoint::Structural)` |\\n\\n\\n## Related works\\nOf ourse, this Phase/Pass architecture didn\u2019t appear out of thin air. It\u2019s shaped by scheduling and deferred commit patterns that have proven themselves in other ECS-driven runtimes. Unity DOTS, for example, structures execution into system groups and uses explicit EntityCommandBuffer playback points to apply structural changes at well-defined times ([Unity Entities: ECB playback](https://docs.unity3d.com/Packages/com.unity.entities@6.5/manual/systems-entity-command-buffers.html)). Bevy follows a similar philosophy with schedules and an explicit `ApplyDeferred` barrier that tells the executor when to apply buffered commands (like `Commands`) ([Bevy: ApplyDeferred](https://docs.rs/bevy/latest/bevy/ecs/schedule/struct.ApplyDeferred.html)). Flecs takes yet another angle on the same idea: Systems often run in a \\"readonly\\" mode where structural changes are deferred and later merged, preserving iteration safety and keeping mutation timing explicit ([Flecs: Systems / readonly & deferred ops](https://www.flecs.dev/flecs/md_docs_2Manual.html#deferred-operations)). helios leans into this family of approaches, but makes the commit semantics first-class: Pass/phase/frame scopes are explicit APIs, and commit points turn \\"when does this become visible?\\" from an implicit convention into a rule you can point at in code.\\n\\n\\n## Looking Forward\\n\\nThe Phase/Pass architecture has proven flexible enough to handle increasingly complex game logic while maintaining determinism. The explicit commit points make it clear when state changes occur, which aids debugging and reasoning about system interactions.\\n\\nI have already started to migrate the underlying systems to a real ECS architecture. The next step is to seal development on the current game demo and start working on the follow up to [the paper on the prototype](https://garagecraft.games/devlog/2025/11/10/helios-design-and-prototypical-implementation-of-a-cpp-game-framework)."},{"id":"/2026-01-05-high-level-overview-of-the-game-loop-architecture/","metadata":{"permalink":"/devlog/2026-01-05-high-level-overview-of-the-game-loop-architecture/","source":"@site/devlog/2026-01-05-high-level-oveview-of-the-game-loop-architecture/index.mdx","title":"helios - A High-Level Overview of the Game Loop Architecture","description":"A deep dive into the architectural separation of concerns in helios. This post outlines how deterministic world mutations are handled via bare-metal Commands and Managers, while decoupled communication relies on a mix of double-buffered and immediate Event Buses to ensure both thread safety and low-latency feedback.","date":"2026-01-05T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"},{"inline":true,"label":"architecture","permalink":"/devlog/tags/architecture"},{"inline":true,"label":"game-loop","permalink":"/devlog/tags/game-loop"},{"inline":true,"label":"events","permalink":"/devlog/tags/events"},{"inline":true,"label":"commands","permalink":"/devlog/tags/commands"},{"inline":true,"label":"double-buffering","permalink":"/devlog/tags/double-buffering"},{"inline":true,"label":"data-oriented-design","permalink":"/devlog/tags/data-oriented-design"}],"readingTime":6.08,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"helios - A High-Level Overview of the Game Loop Architecture","description":"A deep dive into the architectural separation of concerns in helios. This post outlines how deterministic world mutations are handled via bare-metal Commands and Managers, while decoupled communication relies on a mix of double-buffered and immediate Event Buses to ensure both thread safety and low-latency feedback.","date":"2026-01-05","slug":"/2026-01-05-high-level-overview-of-the-game-loop-architecture/","tags":["devlog","helios","architecture","game-loop","events","commands","double-buffering","data-oriented-design"],"keywords":["cpp","game engine","architecture","command pattern","event bus","immediate mode","batch processing","determinism","frame lifecycle"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Phase/Pass Architecture: Evolution of the Game Loop","permalink":"/devlog/2026-02-10-phase-pass-architecture/"},"nextItem":{"title":"New Year\u2019s Eve, New Spawn System","permalink":"/devlog/devlog/2025-12-31-enemy-spawn-system/"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n\\nOver the past few weeks, I\u2019ve been busy refining the helios GameLoop to enable player interactions with various GameObjects. This included, in particular, controlling the player ship, spawning enemies, and - the holy grail of every game - the collision system.\\n\\n\x3c!--truncate--\x3e\\n\\nIt quickly became apparent that a purely object-oriented approach was too brittle and inflexible, leaving me no choice but to read up on a more versatile approach: the component-based system. For me, as an OOP scholar, this meant a paradigm shift in how I design software - but it was worth it.\\n\\n And I\u2019ve come to feel strongly that academic teaching places far too much emphasis on OOP.\\n\\nEven though I am only scratching the surface of proper ECS in this prototype phase, I am very satisfied with the result. However, the problem remained of how to communicate and process cross-frame actions - who orchestrates the spawning? What is a spawn, anyway? Is it an Event? Is it a Command?\\n\\nBased on the collision system, I had to turn the architectural screw a little further - resulting in the following design, which I will be pouring into the framework over the coming weeks.\\n\\n## High-Level Overview of the Game Loop Architecture\\n\\n<Tabs>\\n    <TabItem value=\\"[english]\\">\\n\\n\\n   helios distinguishes between **Commands** (world-mutating operations) and **Events** (signals/facts).\\n   Commands exist to mutate the world state _deterministically_. Events exist to decouple systems: they either express a request/intent (e.g. SpawnRequest) or a fact (e.g. `SolidCollisionEvent`, `TriggerCollisionEvent`, `SpawnedEvent`).\\n\\n   ## Commands and CommandBuffer\\n   Participating systems can write Commands into the CommandBuffer in frame $N$.\\n   At the beginning of each frame $N+1$, the CommandBuffer is flushed, which commits the Commands - i.e. their `execute()` method is invoked. This method contains the logic that mutates the world state (e.g. spawning, despawning, health changes, component changes). Commands are ``bare metal`` and therefore the lowest level in the game-loop layer, i.e. no further preparation of a Command is required. The system should therefore also be able to commit Commands coming directly from a developer console into the GameWorld (optionally delegating them to their respective managers - see below).\\n\\n   ## Events and double-buffered EventBus\\n   In addition, systems can emit Events in frame $N$, e.g. **request events** - events that intend to mutate the world state - or plain signals such as `SolidCollisionEvent`, from which world-mutating Commands (despawn) can be derived.\\n   The EventBus is double-buffered (`helios.core.data.TypeIndexedDoubleBuffer`): events are written into the write buffer in frame $N$ and become visible in the read buffer only after a buffer swap (`swapBuffers()`) at the beginning of frame $N+1$.\\n\\n   At the beginning of frame $N+1$, events are dispatched from the read buffer. As mentioned above, request events can be translated into Commands and written into the CommandBuffer.\\n\\n   This yields the following order at the beginning of frame $N+1$:\\n\\n    ```cpp\\n    EventBus.swapBuffers;()\\n\\n    EventBus.dispatch(); // Events from which Commands may be\\n                        // generated\\n\\n    CommandBuffer.flush(); // Commit - mutates the world state,\\n\\n    ManagerRepository.flush(); // optional manager-based command\\n                              // processing\\n    ```\\n\\n   ### Optional manager-based command processing\\n\\n   Instead of having each Command fully implement the mutation logic in `execute()`, the GameLoop is aware of additional, registered managers. In this model, `execute()` primarily performs a registering/planning step, and the managers then process their work as a coordinated batch.\\n\\n   Example:\\n\\n    ```cpp\\n    CommandBuffer::flush() {\\n        for (auto& cmd : commands)\\n            cmd->execute();   // in execute e.g.:\\n                              // spawnManager->enqueue(position, enemyType);\\n    }\\n\\n    ManagerRepository::flush() {\\n        for (auto& mgr : managers)\\n            mgr->process();   // the spawnManager processes commands,\\n                              // e.g. the spawn list\\n    }\\n    ```\\n\\n   This model allows Commands to be bundled, sorted, and processed deterministically (e.g. handle all spawns first, then all despawns).\\n\\n   ## Immediate Events (single-buffered)\\n   For time-critical feedback that does not mutate the world state (particle effects, audio feedback), there is a separate **ImmediateBus** (single-buffered).\\n   Immediate events should be processed within the same frame without additional double-buffer latency. A suitable dispatch point is after `CommandBuffer.flush()`, so that feedback can observe the world that was committed at the beginning of the frame in a consistent state. This mitigates latency (e.g. ~16ms at 60fps) and allows feedback to be triggered in the same frame as a specific event, which improves the overall user experience (\\"game feel\\").\\n\\n   Overall, the frame-begin order becomes:\\n\\n    ```cpp\\n    EventBus.swapBuffers() // input\\n    EventBus.dispatch()\\n\\n    CommandBuffer.flush(); // mutation\\n\\n    ManagerRepository.flush(); // orchestrating\\n\\n    ImmediateBus.dispatch() // signals\\n\\n    // gameplay systems updating physics\\n    Move2DSystem.update();\\n    ...\\n    ```\\n    </TabItem>\\n    <TabItem value=\\"[deutsch]\\">\\n\\n\\n    helios unterscheidet zwischen **Commands** (weltver\xe4ndernde Mutationen) und **Events** (Signale/Fakten).\\n    Commands dienen dazu, den Weltzustand _deterministisch_ zu ver\xe4ndern. Events dienen dazu, Systeme zu entkoppeln: Sie dr\xfccken entweder einen Request/Intent (z. B. SpawnRequest) oder ein Fakt (z. B. `SolidCollisionEvent`, `TriggerCollisionEvent`, `SpawnedEvent`) aus.\\n\\n    ## Commands und CommandBuffer\\n    Teilnehmende Systeme k\xf6nnen beliebig Commands in Frame $N$ in den CommandBuffer schreiben.\\n    Zu Beginn jedes Frames $N+1$ wird der CommandBuffer geflusht, wodurch die Commands committed werden  - es wird deren `execute()`-Methode aufgerufen. Die Methode enth\xe4lt die Logik, die den Weltzustand mutiert (z. B. Spawning, Despawning, Health-\xc4nderungen, Component-\xc4nderungen). Commands sind``bare metal`` und damit die niedrigste Ebene in der GameLoop-Schicht, d.h., es ist keine weitere Aufbereitung eines Commands mehr n\xf6tig. Das System sollte also auch in der Lage sein, Commands von einer Entwickler-Console direkt in die GameWorld zu \xfcbertragen (ggf. an ihre entsprechenden Manager - s.u.).\\n\\n    ## Events und Double-Buffered EventBus\\n    Zus\xe4tzlich k\xf6nnen Systeme in Frame $N$ Events erzeugen, z. B. **Request Events** - solche bspw. die beabsichtigen, einen den Weltzusatend zu mutieren, oder auch einfach nur Signale, wie bspw. `SolidCollisionEvent`, aus der weltzustandmutierende Commands (despawn) abgeleitet werden.\\n    Der EventBus ist double-buffered (`helios.core.data.TypeIndexedDoubleBuffer`): Events werden in Frame $N$ in den Write-Buffer geschrieben und sind erst nach einem Buffer-Swap (`swapBuffers()`) zu Beginn von Frame $N+1$ im Read-Buffer sichtbar.\\n\\n    Zu Beginn von Frame N+1 werden die Events aus dem Read-Buffer dispatcht; wie oben bereits erw\xe4hnt, k\xf6nnen dabei aus Request-Events wiederum Commands generiert und in den CommandBuffer geschrieben werden.\\n\\n    Daraus ergibt sich zu Beginn von Frame $N+1$ die Reihenfolge:\\n\\n    ```cpp\\n    EventBus.swapBuffers;()\\n\\n    EventBus.dispatch(); // Events from which Commands may be\\n                        // generated\\n\\n    CommandBuffer.flush(); // Commit - mutates the world state,\\n\\n    ManagerRepository.flush(); // optional manager-based command\\n                              // processing\\n    ```\\n\\n    ### Optionale Manager-basierte Command-Verarbeitung\\n    Statt dass jeder Command die Logik einer Mutation vollst\xe4ndig in `execute()` implementiert, verf\xfcgt die GameLoop \xfcber ein ManagerRepository, in dem verschiedene Manager die Ausf\xfchrung von Commands orchestrieren. In diesem Modell f\xfchren Commands in `execute()` prim\xe4r eine registrierende/planende Aktion aus, und die Manager f\xfchren anschlie\xdfend ihre Arbeit koordiniert als Batch aus.\\n\\n    Beispiel:\\n\\n    ```cpp\\n    CommandBuffer::flush() {\\n        for (auto& cmd : commands)\\n            cmd->execute();   // in execute e.g.:\\n                              // spawnManager->enqueue(position, enemyType);\\n    }\\n\\n    ManagerRepository::flush() {\\n        for (auto& mgr : managers)\\n            mgr->process();   // the spawnManager processes commands,\\n                              // e.g. the spawn list\\n    }\\n    ```\\n\\n    Dieses Modell erlaubt es, Commands zu b\xfcndeln, zu sortieren und deterministisch abzuarbeiten (z. B. alle Spawns zusammen, dann alle Despawns).\\n\\n    ## Immediate Events (Single-Buffered)\\n\\n    F\xfcr zeitkritisches Feedback, das nicht den Weltzustand ver\xe4ndert (Partikeleffekte, Audio-Feedback) existiert ein separater **ImmediateBus** (single-buffered).\\n    Immediate-Events sollen im selben Frame ohne zus\xe4tzliche Double-Buffer-Latenz verarbeitet werden. Ein geeigneter Dispatch-Punkt ist nach dem `CommandBuffer.flush()`, damit das Feedback die zu Beginn dieses Frames committete Welt konsistent sehen kann. Hierdurch kann Latenz mitigiert werden (bspw. 16ms bei 60fps) und Feedback kann noch im selben Frame zu einem bestimmten Ereignis gegeben werden, was das \\"Game Feel\\" verbessern kann.\\n\\n    Insgesamt ergibt sich damit zu Frame-Beginn:\\n\\n    ```cpp\\n    EventBus.swapBuffers() // input\\n    EventBus.dispatch()\\n\\n    CommandBuffer.flush(); // mutation\\n\\n    ManagerRepository.flush(); // orchestrating\\n\\n    ImmediateBus.dispatch() // signals\\n\\n    // gameplay systems updating physics\\n    Move2DSystem.update();\\n    ...\\n    ```\\n\\n    </TabItem>\\n</Tabs>"},{"id":"/devlog/2025-12-31-enemy-spawn-system/","metadata":{"permalink":"/devlog/devlog/2025-12-31-enemy-spawn-system/","source":"@site/devlog/2025-12-31-enemy-spawn-system/index.mdx","title":"New Year\u2019s Eve, New Spawn System","description":"Milestone 4 of helios focuses on making gameplay composition easier: a component-based system, game systems for runtime orchestration, an object pool for projectiles for efficient shooting, and simple AABB level-bound collision. Includes demo video and notes on camera/scene-node changes.","date":"2025-12-31T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"},{"inline":true,"label":"milestone3","permalink":"/devlog/tags/milestone-3"},{"inline":true,"label":"game-systems","permalink":"/devlog/tags/game-systems"},{"inline":true,"label":"components","permalink":"/devlog/tags/components"},{"inline":true,"label":"projectile-pool","permalink":"/devlog/tags/projectile-pool"},{"inline":true,"label":"enemy-spawn","permalink":"/devlog/tags/enemy-spawn"},{"inline":true,"label":"aabb","permalink":"/devlog/tags/aabb"},{"inline":true,"label":"gameplay","permalink":"/devlog/tags/gameplay"}],"readingTime":0.41,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"New Year\u2019s Eve, New Spawn System","description":"Milestone 4 of helios focuses on making gameplay composition easier: a component-based system, game systems for runtime orchestration, an object pool for projectiles for efficient shooting, and simple AABB level-bound collision. Includes demo video and notes on camera/scene-node changes.","date":"2025-12-31","slug":"/devlog/2025-12-31-enemy-spawn-system/","tags":["devlog","helios","milestone3","game-systems","components","projectile-pool","enemy-spawn","aabb","gameplay"],"keywords":["cpp","game framework","components","projectile","pooling","aabb","camera","scene graph","indiedev","spaceship","input","spawn-system"],"authors":["thorstensuckow"],"seo_title":"New Year\u2019s Eve, New Spawn System","seo_description":"Helios Milestone 3 introduces a component-based approach and game systems for composing behaviors, projectile pooling for efficient shooting, and AABB level bounds collision. View demo and developer notes.","canonical_url":"https://garagecraft.games/devlog/2025-12-31-enemy-spawn-system/"},"unlisted":false,"prevItem":{"title":"helios - A High-Level Overview of the Game Loop Architecture","permalink":"/devlog/2026-01-05-high-level-overview-of-the-game-loop-architecture/"},"nextItem":{"title":"\ud83c\udf84 Milestone 3: Game Systems, Components, Projectiles and Boundaries \ud83c\udf81","permalink":"/devlog/2025/12/25/milestone3-release"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nWrapping up the year with GameObject pooling and a SpawnSystem based on conditions and strategies. On to collision detection! \ud83d\udd79\ufe0f \ud83d\udc7e\\n\\n\\n\x3c!--truncate--\x3e\\n\\nimport enemy_spawn from \\"./img/enemy_spawn.webm\\";\\n\\n<div style={{ textAlign: \'center\' }}>\\n  <video\\n    autoPlay\\n    loop\\n    controls\\n    muted\\n    playsInline\\n    preload=\\"metadata\\"\\n    poster=\\"/img/enemy_spawn.png\\"\\n    aria-label=\\"Enemy Spawn demo\\"\\n    style={{ maxWidth: \'100%\', height: \'auto\', maxHeight: \'480px\', display: \'block\', margin: \'0 auto\' }}\\n  >\\n    <source src={enemy_spawn} type=\\"video/webm\\" />\\n  </video>\\n</div>\\n\\nWishing you a smooth start into the new year!\\n\\n<SocialLinks />"},{"id":"/2025/12/25/milestone3-release","metadata":{"permalink":"/devlog/2025/12/25/milestone3-release","source":"@site/devlog/2025-12-25-milestone3-release/index.mdx","title":"\ud83c\udf84 Milestone 3: Game Systems, Components, Projectiles and Boundaries \ud83c\udf81","description":"helios milestone 3 adds game systems, a component-based approach for composing behavior, projectile pooling for shooting, and simple AABB level bounds collision.","date":"2025-12-25T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"},{"inline":true,"label":"milestone3","permalink":"/devlog/tags/milestone-3"},{"inline":true,"label":"game-systems","permalink":"/devlog/tags/game-systems"},{"inline":true,"label":"components","permalink":"/devlog/tags/components"}],"readingTime":3.51,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"\ud83c\udf84 Milestone 3: Game Systems, Components, Projectiles and Boundaries \ud83c\udf81","description":"helios milestone 3 adds game systems, a component-based approach for composing behavior, projectile pooling for shooting, and simple AABB level bounds collision.","tags":["devlog","helios","milestone3","game-systems","components"],"keywords":["cpp","game framework","components","projectile","pooling","aabb","camera","scene graph","indiedev","spaceship","input"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"New Year\u2019s Eve, New Spawn System","permalink":"/devlog/devlog/2025-12-31-enemy-spawn-system/"},"nextItem":{"title":"Milestone 2: Scene Graph, Gamepad Widgets, and a Flying Spaceship","permalink":"/devlog/2025/12/16/milestone2-release"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nMerry Christmas - Milestone 3 is out. This one is smaller on flashy visuals but much bigger where it matters: the framework now helps to build gameplay faster. Over the last week I focused on three practical gaps that showed up while iterating on the spaceship demo: clearer system boundaries, easier composition of behavior, and stable, cheap shooting.\\n\\n\x3c!--truncate--\x3e\\n\\nimport spaceship_shooting from \\"./img/spaceship_shooting.webm\\";\\n\\n<div style={{ textAlign: \'center\' }}>\\n  <video\\n    autoPlay\\n    loop\\n    controls\\n    muted\\n    playsInline\\n    preload=\\"metadata\\"\\n    poster=\\"/img/spaceship_shooting_poster.png\\"\\n    aria-label=\\"Spaceship shooting demo\\"\\n    style={{ maxWidth: \'100%\', height: \'auto\', maxHeight: \'480px\', display: \'block\', margin: \'0 auto\' }}\\n  >\\n    <source src={spaceship_shooting} type=\\"video/webm\\" />\\n  </video>\\n</div>\\n\\n\\n## What landed in Milestone 3\\n\\nShort version: game systems, a component model for game objects, a projectile pool for shooting, and axis\u2011aligned bounding box (AABB) level bounds for simple collision and containment.\\n\\nI decided to keep the implementation small and pragmatic. Nothing over\u2011engineered, just clean primitives that make the next iterations easier to build.\\n\\n### Game Systems\\n\\nA tiny system layer now orchestrates update steps and lifecycles for subsystems like the physics and collision step, the game object update step and any gameplay systems I plan to add later (spawning, AI, audio, etc.). The idea is to avoid ad\u2011hoc update calls scattered across the codebase and instead have a clear place each frame where systems run in a deterministic order.\\n\\nThis also makes testing and replaying input simpler because systems operate on snapshots and command buffers rather than being driven by side\u2011effects in input handlers.\\n\\n### Composition over Inheritance (The Gang of Four was right)\\n\\nIt became obvious early after milestone 2 that OOP inheritance was getting brittle. For Milestone 3 I added a small component model: lightweight components attach to `GameObject`s (or entities) and expose behaviour such as movement, weapon emitters, or renderables.\\n\\nThis lets me compose behavior at runtime: instead of creating a new subclass for every combination (PlayerShipWithLaserAndShield), I attach a `LevelBoundsBehavior` component and a `Shooting` component to the same object, cutting down code duplication and speed up experimentation.\\n\\n```cpp\\nauto shipGameObject = std::make_unique<helios::engine::game::GameObject>();\\nshipGameObject->add<helios::engine::game::components::scene::SceneNodeComponent>(spaceshipSceneNode);\\nshipGameObject->add<helios::engine::game::components::input::TwinStickInputComponent>();\\nshipGameObject->add<helios::engine::game::components::physics::Move2DComponent>();\\nshipGameObject->add<helios::engine::game::components::physics::TransformComponent>();\\nshipGameObject->add<helios::engine::game::components::physics::ScaleComponent>(\\n    SPACESHIP_SIZE, SPACESHIP_SIZE, 0.0f, helios::core::units::Unit::Meter);\\nshipGameObject->add<helios::engine::game::components::gameplay::Aim2DComponent>();\\nshipGameObject->add<helios::engine::game::components::gameplay::ShootComponent>();\\nshipGameObject->add<helios::engine::game::components::physics::LevelBoundsBehaviorComponent>();\\nshipGameObject->add<helios::engine::game::components::physics::AabbColliderComponent>();\\n\\n//...\\n\\ngameWorld.add<helios::engine::game::systems::physics::ScaleSystem>();\\ngameWorld.add<helios::engine::game::systems::physics::Move2DSystem>();\\ngameWorld.add<helios::engine::game::systems::scene::SceneSyncSystem>(scene.get());\\ngameWorld.add<helios::engine::game::systems::physics::BoundsUpdateSystem>();\\ngameWorld.add<helios::engine::game::systems::physics::LevelBoundsBehaviorSystem>();\\ngameWorld.add<helios::engine::game::systems::post::TransformClearSystem>();\\ngameWorld.add<helios::engine::game::systems::post::ScaleClearSystem>();\\n\\n```\\n\\nPractical note: components live alongside the existing scene graph and play nicely with the `GameWorld`/`GameObject` container I had in place, the integration is intentionally minimal and explicit. However, there is a tight coupling to the `SceneGraph` as an authoritative source of transforms for game objects with visual representation, which keeps things simple for now. This i definitely an area to revisit later as the framework matures.\\n\\n### Shooting: Projectile Pool\\n\\nShooting is now implemented using a simple object pool of projectiles. The pool recycles projectile objects instead of allocating/freeing them every time you fire. For the small demos this eliminates frame spikes and is simpler than introducing a full allocator or rendering instancing right away.\\n\\nInstancing is already on my roadmap and I can\'t wait to see how the performance gains will impact the render time.\\n\\n### AABB Level Bounds - keep things inside the playground\\n\\nI added a basic axis\u2011aligned bounding box behavior for level bounds. It does two things: Preventing player objects from leaving the designed area, and giving projectiles a simple rule for when they should be recycled (leave the AABB => return to pool).\\n\\nThis keeps the demo predictable and lets me tune gameplay without surprises from objects drifting out of the level boundaries (i.e., the world :) ).\\n\\n\\n\\nHappy holidays \ud83c\udf84 and thanks for following along!\\n\\n<SocialLinks />"},{"id":"/2025/12/16/milestone2-release","metadata":{"permalink":"/devlog/2025/12/16/milestone2-release","source":"@site/devlog/2025-12-16-milestone2-release/index.mdx","title":"Milestone 2: Scene Graph, Gamepad Widgets, and a Flying Spaceship","description":"helios v0.1.0-milestone2 brings scene graph camera integration, gamepad customization, ImGui dev tools, and an interactive spaceship demo","date":"2025-12-16T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":5.72,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Milestone 2: Scene Graph, Gamepad Widgets, and a Flying Spaceship","description":"helios v0.1.0-milestone2 brings scene graph camera integration, gamepad customization, ImGui dev tools, and an interactive spaceship demo","tags":["devlog","helios"],"keywords":["cpp","scene graph","camera","gamepad","imgui","game framework","indiedev","spaceship","input handling","milestone"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"\ud83c\udf84 Milestone 3: Game Systems, Components, Projectiles and Boundaries \ud83c\udf81","permalink":"/devlog/2025/12/25/milestone3-release"},"nextItem":{"title":"ImGui Integration and Breaking Changes","permalink":"/devlog/2025/12/04/imgui-integration-and-breaking-changes"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nMilestone 2 is out. I originally planned to add some camera controls, but ended up rewriting how cameras integrate with the scene graph entirely. Along the way I also built the foundations for the game object system, a bunch of ImGui debug widgets, and a small spaceship demo where you fly around with a gamepad.\\n\\n\x3c!--truncate--\x3e\\n\\n## Camera Refactor\\n\\nIn milestone_1, `Camera` inherited from `SceneNode`. That worked, but it always felt a bit off - a camera is really just a viewpoint, not a scene object. Having cameras inherit all the scene node behavior led to some awkward edge cases.\\n\\nThe new design flips it around: `CameraSceneNode` now wraps a `Camera` component. The node participates in the transform hierarchy, the camera handles projection and view logic. Much cleaner separation.\\n\\nThe big win here is component-wise transform inheritance: Say you have a camera following a spaceship - you probably want the camera to track the ship\'s position, but not roll when the ship does. With `TransformType` flags you can now pick exactly what gets inherited:\\n\\n```cpp\\nauto camera = std::make_unique<Camera>();\\nauto cameraNode = std::make_unique<CameraSceneNode>(std::move(camera));\\n\\n// Only inherit translation from parent - ignore rotation and scale\\ncameraNode->setInheritance(TransformType::Translation);\\n\\nauto* nodePtr = scene->addNode(std::move(cameraNode));\\n```\\n\\nThe view matrix now comes from the inverse world transform of the camera node, so all the existing hierarchy logic I had for other nodes just works here too.\\n\\n## Game Objects and Commands\\n\\nI went back and forth on the concepts of ECS, but decided to keep it simple with plain old OOP/inheritance: I landed on a basic `GameObject` class with GUID identification and a `GameWorld` container. Nothing fancy, but it covers what helios needs right now.\\n\\nThe part I like is the `CommandBuffer`. Instead of having input handlers execute game logic directly, they push commands to a buffer that gets processed once per frame. Same inputs in the same frame always produce the same result, and it opens the door for replays later:\\n\\n```cpp\\nconst auto stick = inputSnapshot.gamepadState().left();\\nfloat speed      = stick.length();\\nspeed = speed <= helios::math::EPSILON_LENGTH ? 0.0f : speed;\\n\\nhelios::math::vec2f dir = speed > 0.0f\\n                            ? stick * (1.0f/speed)\\n                            : helios::math::vec2f{0.0f, 0.0f};\\n\\ncommandBuffer.add(\\n    guid,\\n    std::make_unique<\\n    helios::examples::spaceshipControl::commands::PlayerMoveCommand\\n    >(dir, speed)\\n);\\n```\\n\\n## Gamepad Config\\n\\nI\'ve been testing with a couple of different controllers: An old Xbox Elite Series 2 pad (whose best days are long gone) and a GameSir G7 (which really deserves all the praise it got in reviews - minus the dpad). The important thing for debugging was that they all behave slightly differently when it comes to stick drift and axis ranges.\\nSo I added `GamepadSettings` for per-controller deadzone thresholds and axis inversion. The deadzones use a radial strategy, which gets rid of that annoying diagonal drift you get with cheap analog sticks. The `GamepadWidget` exposes all of this at runtime with sliders and toggles, which beats recompiling every time I want to try a different threshold.\\n\\n## Units\\n\\nThis is one of those things I should have done from the start: helios now has a proper units system. One helios unit equals one meter, time is measured in seconds. There are conversion helpers for when you need centimeters or milliseconds:\\n\\n```cpp\\nusing namespace helios::core::units;\\n\\nfloat distance = from(50.0, helios::core::units::Unit::Centimeter);  // 0.5\\n```\\n\\n## Spaceship Demo\\n\\nThe `spaceship_control` example brings everything together: a small spaceship you fly with gamepad, a camera parented to the ship that inherits only translation (so it follows position but stays level when the ship rotates), and the ImGui overlay for tweaking things live.\\n\\nInput flows through `InputSnapshot`, the handler creates movement commands, and the `CommandBuffer` executes them each frame. It\'s more architecture than a demo strictly needs, but it validates that the systems work together. And flying the spaceship around is genuinely fun.\\n\\n<center>\\n![](img/spaceship_control.gif)\\n</center>\\n\\n## Breaking Changes\\n\\nIf you\'re coming from milestone_1, a few things moved around:\\n\\n- **Cameras**: `CameraSceneNode` now wraps `Camera`, not the other way around. Viewport uses `setCameraSceneNode()`.\\n- **Enum sentinels**: Renamed from `COUNT` to `size_` everywhere for consistency.\\n- **MeshData**: Merged into `Mesh`.\\n- **Material**: Now owns shader and properties via shared_ptr.\\n\\nThe camera change is the disruptive one, but the component-wise transform inheritance makes the migration worth it.\\n\\n## Next\\n\\nThe scene graph works the way I want now, input handling is solid, and I have debug tools that save time. The obvious gap is that everything still looks like colored shapes. Next milestone will focus on shooting bullets and basic collision detection, so the ship doesn\'t leave the arena.\\n\\n[Pre-built binaries can be found here](https://github.com/ThorstenSuckow/helios/releases) if you want to try the examples.\\n\\n## Usage of Copilot in this Milestone\\n\\n### Code Generation\\nI ended up spending more time on debug widgets than I originally planned, but having good tools makes everything else faster. I saw this as a good opportunity to try GitHub Copilot for code generation, so I gave it a shot for the ImGui widgets after I implemented the basic ImGui-related API.\\n\\n Copilot generated boilerplate code for the widgets based on my comments and function signatures, which saved me a lot of typing. I still had to tweak the generated code to fit my architecture and style to some extent, but it was a helpful starting point and impressive to see how far models like Claude Opus 4.5 have come.\\n\\nHere\'s what was built with the help of Claude Opus 4.5, Gemini 3 Pro and ChatGPT-5.1-Codex:\\n\\n| Widget | What it does |\\n|--------|-------------|\\n| `FpsWidget` | Frame rate display, target FPS control |\\n| `GamepadWidget` | Real-time stick visualization, deadzone config |\\n| `LogWidget` | Searchable log console with scope filtering |\\n| `CameraWidget` | Position, orientation, projection controls |\\n| `MainMenuWidget` | Theme switching, docking options |\\n\\nThe `LogWidget` hooks into the logging system through a custom `ImGuiLogSink`. You can filter by scope and search through the output while the app is running. I\'ve already found bugs in minutes that would have taken me much longer with plain console output.\\n\\n### Code Review\\nAs a solo dev, I\'ve also come to appreciate GitHub\'s Copilot code review. No colleagues to catch my mistakes, but at least I get a second pair of \\"eyes\\" on pull requests before merging.\\n\\n### Manifesto for AI-Augmented Software Craftsmanship\\n\\nAs I have stated in a [previous post](http://garagecraft.games/devlog/2025/11/25/value-driven-game-development-in-the-age-of%20-aI-assistance), it is important to me that I understand what I\'m building. Using AI tools for boilerplate generation and code review helps me focus on the architecture and design decisions, while still ensuring that I grasp the underlying concepts. To add transparency to my use of AI tools, I have documented my approach in [The Manifesto for AI-Augmented Software Craftsmanship](https://ai-manifesto.software-craftsmanship.dev), which I also discussed [in more detail here](https://thorsten.suckow-homberg.de/blog/manifesto-for-ai-augmented-software-craftsmanship).\\n\\n<SocialLinks />"},{"id":"/2025/12/04/imgui-integration-and-breaking-changes","metadata":{"permalink":"/devlog/2025/12/04/imgui-integration-and-breaking-changes","source":"@site/devlog/2025-12-04-imgui-integration-and-breaking-changes/index.mdx","title":"ImGui Integration and Breaking Changes","description":"Frame pacing, debug overlays, and architectural improvements - preparing for the next milestone","date":"2025-12-04T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":2.11,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"ImGui Integration and Breaking Changes","description":"Frame pacing, debug overlays, and architectural improvements - preparing for the next milestone","tags":["devlog","helios"],"keywords":["cpp","imgui","frame pacing","fps","debug tools","breaking changes","architecture","refactoring"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Milestone 2: Scene Graph, Gamepad Widgets, and a Flying Spaceship","permalink":"/devlog/2025/12/16/milestone2-release"},"nextItem":{"title":"AI Assistance in Game Development","permalink":"/devlog/2025/11/25/value-driven-game-development-in-the-age-of -aI-assistance"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nSince wrapping up [milestone_1](https://www.researchgate.net/publication/397445662_helios_Design_and_prototypical_implementation_of_a_C_game_framework) in October, I\'ve been working on tooling and performance infrastructure. The focus has been on frame timing control and debugging capabilities - things you need before scaling up to more complex scenes.\\n\\n\x3c!--truncate--\x3e\\n\\n## Frame Timing Infrastructure\\n\\nFrame rate control is now in place with three new classes: `FramePacer` handles the actual frame rate limiting, `FrameStats` tracks timing information, and `FpsMetrics` analyzes performance over time. There\'s also a `Stopwatch` for high-resolution timing measurements.\\n\\nThe implementation is straightforward - the `FramePacer` ensures consistent frame times, which is important for physics integration later. Right now it\'s just preventing the GPU from running at 100% unnecessarily.\\n\\n## ImGui Integration\\n\\nI\'ve added an ImGui layer for debug overlays. The architecture is split into:\\n- `ImGuiBackend` - platform abstraction\\n- `ImGuiGlfwOpenGLBackend` - concrete GLFW/OpenGL implementation\\n- `ImGuiOverlay` - singleton manager for widgets\\n- `ImGuiWidget` - base interface for custom widgets\\n\\nThree widgets are currently implemented: `FpsWidget` for frame rate display, `GamepadWidget` for controller input visualization, and `LogWidget` - a scrollable console with log filtering.\\n\\nThe overlay system makes it easy to toggle debug info on and off, which has already helped with tracking down frame timing issues.\\n\\n<center>\\n![](img/imgui_overlay.gif)\\n</center>\\n\\n## Breaking Changes\\n\\nAlong the way, I\'ve made some architectural improvements that required breaking changes:\\n\\n**Enum sentinels** are now consistently named `size_` across the codebase. Before, some enums used `COUNT`, others `SIZE`, some `size`. The trailing underscore avoids macro conflicts and works better with code generation tools.\\n\\n```cpp\\n// Before\\nenum class Key { A, B, C, COUNT };\\n\\n// After\\nenum class Key { A, B, C, size_ };\\n```\\n\\n**MeshData merged with Mesh**. The separate `MeshData` class was redundant - `Mesh` now handles geometry directly.\\n\\n**New RenderPrototype abstraction**. The rendering setup now uses a `RenderPrototype` that combines `Material` and `Mesh`. A `Renderable` then references this prototype, optionally with a `MaterialPropertiesOverride` for per-instance variations:\\n\\n```cpp\\n// Material = Shader + MaterialProperties\\nauto materialProps = std::make_shared<MaterialProperties>(\\n    vec4f(1.0f, 0.0f, 1.0f, 0.5f), 0.0f\\n);\\nauto material = std::make_shared<Material>(shader, materialProps);\\n\\n// RenderPrototype = Material + Mesh\\nauto prototype = std::make_shared<RenderPrototype>(material, mesh);\\n\\n// Renderable with optional per-instance override\\nauto renderable = std::make_shared<Renderable>(\\n    prototype,\\n    MaterialPropertiesOverride(vec4f(0.25f, 0.96f, 0.35f, 0.5f), 0.0f)\\n);\\n```\\n\\nThis separates shared resources (prototype) from instance-specific data (override), which is useful when rendering multiple objects with the same mesh but different colors.\\n\\n\\n## What\'s Next\\n\\nWith frame timing and debug tools in place, I can focus on the actual game logic. The input system is solid, the rendering pipeline handles basic geometry, and the scene graph works. Time to build something that moves.\\n\\n<SocialLinks />"},{"id":"/2025/11/25/value-driven-game-development-in-the-age-of -aI-assistance","metadata":{"permalink":"/devlog/2025/11/25/value-driven-game-development-in-the-age-of -aI-assistance","source":"@site/devlog/2025-11-25-value-driven-game-development-in-the-age-of -aI-assistance/index.mdx","title":"AI Assistance in Game Development","description":"Thoughts on keeping the craft in craftsmanship when AI tools are everywhere","date":"2025-11-25T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":true,"label":"thoughts","permalink":"/devlog/tags/thoughts"}],"readingTime":1.17,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"AI Assistance in Game Development","description":"Thoughts on keeping the craft in craftsmanship when AI tools are everywhere","tags":["devlog","thoughts"],"keywords":["ai","software craftsmanship","game development","indiedev","github copilot","claude","manifesto"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"ImGui Integration and Breaking Changes","permalink":"/devlog/2025/12/04/imgui-integration-and-breaking-changes"},"nextItem":{"title":"helios: Design and prototypical implementation of a C++ game framework","permalink":"/devlog/2025/11/10/helios-design-and-prototypical-implementation-of-a-cpp-game-framework"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nI use [GitHub Copilot](https://github.com/features/copilot) mainly for Code Reviews. I think it\'s tremendously helpful when working on a solo project with a large codebase as it hints at typos and logic issues that easily slip under the radar when writing only coarse-grained tests for the sake of it. I also tried [Claude](https://claude.ai) and [Gemini](https://gemini.google.com). All those tools are sometimes helpful, sometimes annoying.\\n\\nWhat\'s been on my mind: when I accept code I haven\'t thought through myself - do I still understand what I\'m actually building?\\n\\n\x3c!--truncate--\x3e\\n\\nWith [helios](https://helios.garagecraft.games) being the education project it is, understanding is the whole point. All those [articles on my personal website](https://thorsten.suckow-homberg.de) on computer graphics and software design - I\'m not writing them because I already know this stuff, but because I want to learn it. If an AI generates my transformation matrix, I\'ve learned nothing. (Might as well just use Unity.)\\n\\nSure, for boilerplate or when I\'m writing the same unit test for the third time, Copilot is great. But architecture decisions? I want to think those through myself.\\n\\nI wrote something about this: [The Manifesto for AI-Augmented Software Craftsmanship](https://ai-manifesto.software-craftsmanship.dev). It\'s about not forgetting why we\'re doing this in the first place.\\n\\nMore on that [here](https://thorsten.suckow-homberg.de/blog/manifesto-for-ai-augmented-software-craftsmanship).\\n\\n<SocialLinks />"},{"id":"/2025/11/10/helios-design-and-prototypical-implementation-of-a-cpp-game-framework","metadata":{"permalink":"/devlog/2025/11/10/helios-design-and-prototypical-implementation-of-a-cpp-game-framework","source":"@site/devlog/2025-11-10-helios-design-and-prototypical-implementation-of-a-cpp-game-framework/index.mdx","title":"helios: Design and prototypical implementation of a C++ game framework","description":"Technical report on helios - architectural decisions, SOLID principles, and data-oriented design","date":"2025-11-10T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.83,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"helios: Design and prototypical implementation of a C++ game framework","description":"Technical report on helios - architectural decisions, SOLID principles, and data-oriented design","tags":["devlog","helios"],"keywords":["cpp","game framework","helios","technical report","architecture","solid principles","data oriented design","tracer bullet development","researchgate"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"AI Assistance in Game Development","permalink":"/devlog/2025/11/25/value-driven-game-development-in-the-age-of -aI-assistance"},"nextItem":{"title":"Just make it exist first","permalink":"/devlog/2025/10/19/just-make-it-exist-first"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\nimport papershot from \\"./img/papershot.png\\";\\n\\n## Finishing milestone_1\\n\\nI\'ve published an accompanying technical report on my game framework **helios** that outlines the key architectural decisions behind the prototype and discuss its further development.\\n\\n\\n \x3c!--truncate--\x3e\\n\\n<center>\\n<a href=\\"https://www.researchgate.net/publication/397445662_helios_Design_and_prototypical_implementation_of_a_C_game_framework\\" target=\\"_blank\\"><img width=\\"400\\" src={papershot} /></a>\\n</center>\\n\\nThe report examines the development progress through the first milestone, highlights architectural decisions, and reflects on implementation challenges - with a deliberate focus on system design considerations.\\n\\nIt explores the use of agile Tracer Bullet Development, the advantages of SOLID principles during prototyping, and the tension between expressive object-oriented semantics and efficient data-oriented design (DOD) - an approach increasingly established in modern, performance-optimized game engines.\\n\\nI look forward to using this document upon project completion as a critical reflection, helping to make the insights gained throughout the development process transparent.\\n\\n\\nIt\'s [available for download](https://www.researchgate.net/publication/397445662_helios_Design_and_prototypical_implementation_of_a_C_game_framework) on my [ResearchGate profile page](https://www.researchgate.net/profile/Thorsten-Suckow-Homberg).\\n\\n\\n\\n<SocialLinks />"},{"id":"/2025/10/19/just-make-it-exist-first","metadata":{"permalink":"/devlog/2025/10/19/just-make-it-exist-first","source":"@site/devlog/2025-10-19-just-make-it-exist-first/index.mdx","title":"Just make it exist first","description":"Prototyping the rendering pipeline - SceneGraph, RenderPass, RenderQueue, and RenderCommands","date":"2025-10-19T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.84,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Just make it exist first","description":"Prototyping the rendering pipeline - SceneGraph, RenderPass, RenderQueue, and RenderCommands","tags":["devlog","helios"],"keywords":["cpp","rendering pipeline","scene graph","render pass","render queue","culling","snapshot","factory pattern"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"helios: Design and prototypical implementation of a C++ game framework","permalink":"/devlog/2025/11/10/helios-design-and-prototypical-implementation-of-a-cpp-game-framework"},"nextItem":{"title":"Onwards to the rendering model","permalink":"/devlog/2025/09/28/onwards-to-the-rendering-model"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n## Prototyping the Rendering Pipeline\\n\\n<center>\\n![](img/justmakeitexistfirst.gif)\\n</center>\\nAs [announced in a previous post](/devlog/2025/09/28/onwards-to-the-rendering-model), I\'ve made progress on the rendering pipeline. The `SceneGraph` and `RenderPass` system are in place now, separating scene graph traversal from the actual rendering commands.\\n\\n \x3c!--truncate--\x3e\\n\\nI added a `RenderPassFactory` that takes a scene `Snapshot` and converts it into `RenderCommands`. The goal was to decouple what\'s in the scene (meshes, materials) from how it gets rendered. It\'s working, though there\'s room for improvement - but I\'m avoiding feature creep for now.\\n\\nHere\'s the basic flow:\\n\\n```\\ncreate SceneGraph -> take Snapshot -> create RenderPass\\n                                               ||\\n                                               \\\\/\\n        process by RenderingDevice <- extract RenderQueue\\n```\\n\\nThe `RenderingDevice` iterates over the `RenderQueues` and processes the `Renderables`, which is where the actual rendering happens.\\n\\nNext up: generating doxygen documentation and integrating the input subsystem. I\'m using helios as the framework for a semester assignment at [Trier University of Applied Sciences](https://www.hochschule-trier.de), so having proper documentation is becoming important.\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/28/onwards-to-the-rendering-model","metadata":{"permalink":"/devlog/2025/09/28/onwards-to-the-rendering-model","source":"@site/devlog/2025-09-28-onwards-to-the-rendering-model/index.mdx","title":"Onwards to the rendering model","description":"First abstractions for rendering - Vertex, Mesh, Material, and Shader separation of concerns","date":"2025-09-28T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":1.23,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Onwards to the rendering model","description":"First abstractions for rendering - Vertex, Mesh, Material, and Shader separation of concerns","tags":["devlog","helios"],"keywords":["cpp","rendering","opengl","vertex","mesh","material","shader","learnopengl","modules","move semantics"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Just make it exist first","permalink":"/devlog/2025/10/19/just-make-it-exist-first"},"nextItem":{"title":"Event Queue and Application Controllers","permalink":"/devlog/2025/09/22/from-eventqueue-to-app-controller"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nThe first abstractions for the rendering model have found their way into **helios**, and the first example application has already rendered its first primitives onto the screen (aka the `Hello World!` of 3D Computer Graphics).\\n\\n[de Vries\'](https://joeydevries.com/) book on [OpenGL](https://learnopengl.com) is proving (once again) to be very useful, as it provides some common, coarse-grained abstractions that serve as a great starting point for further refinement. Think of separating concerns like Meshes, Materials, and Shaders.\\n\\n \x3c!--truncate--\x3e\\n                                                                      I\'m striving for a more loosely coupled (and hopefully maintainable) relationship between these entities. The goal is for Shaders to be reusable across multiple Material instances, which in turn can be applied to multiple Mesh instances, with each mesh being uniquely owned by a renderable node... it\'s (unintentionally) **think big** at this point: Here\'s hoping I don\'t end up shooting myself in the foot!\\n\\n\\nHere\'s a look at the foundational data structure the rendering is built on:\\n```cpp\\nmodule;\\n\\nexport module helios.rendering.core.Vertex;\\n\\nimport helios.math.types;\\n\\nexport namespace helios::rendering::core {\\n\\n    /**\\n     * Represents a standard vertex with position, normal,\\n     * and texture coordinates.\\n     *\\n     * @see [Vri20, pp. 160]\\n     */\\n    struct Vertex {\\n        math::vec3 position;\\n        math::vec3 normal;\\n        math::vec2 texCoords;\\n    };\\n}\\n\\n```\\n\\nI have also added a first (short) draft for the coding style guide. I expect a few changes here and there in the upcoming weeks, since I\'m still not quite acquainted with the **C++** ecosystem. However, move semantics are really starting to grow on me.\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/22/from-eventqueue-to-app-controller","metadata":{"permalink":"/devlog/2025/09/22/from-eventqueue-to-app-controller","source":"@site/devlog/2025-09-22-from-eventqueue-to-app-controller/index.mdx","title":"Event Queue and Application Controllers","description":"Building an event-driven architecture - EventManager, Controllers, and the Hollywood Principle","date":"2025-09-22T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":1.54,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Event Queue and Application Controllers","description":"Building an event-driven architecture - EventManager, Controllers, and the Hollywood Principle","tags":["devlog","helios"],"keywords":["cpp","event system","event queue","architecture","controller pattern","hollywood principle","glfw","raii"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Onwards to the rendering model","permalink":"/devlog/2025/09/28/onwards-to-the-rendering-model"},"nextItem":{"title":"From Camera- to Clip-Space, to NDCs and z-Fighting","permalink":"/devlog/2025/09/17/orthographic-and-perspective-projection"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n\\n## The endless tale of yet-another-framework\\n\\nI feel that I\'ve spent most of my recent time with refactoring, restructuring, and developing throwaway prototypes that get discarded every weekend - and that\'s a good thing. The time between development cycles is currently filled with the intense evaluation of algorithms in digital image processing and reading through [Game Engine Architecture](https://www.gameenginebook.com/) by [Jason Gregory](https://www.linkedin.com/in/jason-gregory-35669b1/), which repeatedly provides me with new perspectives.\\n\\n \x3c!--truncate--\x3e\\n\\n### Event-driven before we even step into the game loop\\nAt the heart of the newest addition lies an event dispatching system that closes the gap between the application layer and the inner workings of the main loop. The implementation follows the usual design paradigms like [**Don\'t call us, we\'ll call you**](https://martinfowler.com/bliki/HollywoodPrinciple.html), as well as decoupling and extracting responsibilities so they become more maintainable and interchangeable. In short: based on my experience as a long-time GUI/frontend developer, I\'m untangling dependencies before they even occur and letting the components broadcast their state changes as distinct Event objects through a central EventManager.\\n\\nIn addition, I have provided a structured home for the logic embodied by those signals - `Controller` classes. This pattern ensures that behavior is neatly encapsulated, with initial implementations like a `WindowRenderingController` handling specific domains of logic and mediating between the Window subsystem and the rendering engine (`glViewport()` says _hello_).\\n\\nThis foundational change was accompanied by other (minor) improvements and housekeeping: The GLFW-specific functionality was refactored into its own orthogonal module, public-facing APIs were simplified through the use of facades, and a new RAII guard was implemented to ensure deterministic resource lifecycle management.\\n\\nRight now, it\'s a pleasure to work with C++, and I can\'t wait until I step one layer deeper into the game engine\'s subsystems.\\n\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/17/orthographic-and-perspective-projection","metadata":{"permalink":"/devlog/2025/09/17/orthographic-and-perspective-projection","source":"@site/devlog/2025-09-17-orthographic-and-perspective-projection/index.mdx","title":"From Camera- to Clip-Space, to NDCs and z-Fighting","description":"Deriving orthographic and perspective projection matrices - from camera space to clip space","date":"2025-09-17T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.46,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"From Camera- to Clip-Space, to NDCs and z-Fighting","description":"Deriving orthographic and perspective projection matrices - from camera space to clip space","tags":["devlog","helios"],"keywords":["linear algebra","projection matrices","orthographic projection","perspective projection","clip space","ndc","opengl","camera"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Event Queue and Application Controllers","permalink":"/devlog/2025/09/22/from-eventqueue-to-app-controller"},"nextItem":{"title":"Updates to main()","permalink":"/devlog/2025/09/14/updates-to-main"}},"content":"import CubeOrthoIso from \\"./img/ortho_proj_cube_iso_small.gif\\";\\nimport {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n<center>\\n<img style={{mixBlendMode:\\"screen\\",filter:\\"invert(1)\\"}} src={CubeOrthoIso} />\\n</center>\\nContinuing from [my article on Model Matrix Rotations](/devlog/2025/09/02/model-matrix-rotations), I\'ve written about projection matrices - one of the final steps before rasterization.\\n\\n \x3c!--truncate--\x3e\\n\\nThe [article](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/from-camera-to-clip-space-derivation-of-the-projection-matrices) derives both orthographic and perspective projection matrices, showing how view volumes in camera space are transformed into the canonical unit cube.\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/14/updates-to-main","metadata":{"permalink":"/devlog/2025/09/14/updates-to-main","source":"@site/devlog/2025-09-14-updates-to-main/index.mdx","title":"Updates to main()","description":"Refactoring the main loop - OpenGLDevice, GLFWApplication, and the first tick() implementation","date":"2025-09-14T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":1.06,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Updates to main()","description":"Refactoring the main loop - OpenGLDevice, GLFWApplication, and the first tick() implementation","tags":["devlog","helios"],"keywords":["cpp","game loop","tick","delta time","opengl","glfw","main loop","input manager","architecture"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"From Camera- to Clip-Space, to NDCs and z-Fighting","permalink":"/devlog/2025/09/17/orthographic-and-perspective-projection"},"nextItem":{"title":"The Great Modular Restructuring","permalink":"/devlog/2025/09/13/the-great-modular-restructuring"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### In the spirit of yesterday\'s refactoring efforts...\\n\\n`main()` serves as a great example of [yesterday\'s](/devlog/2025/09/13/the-great-modular-restructuring) restructuring in practice: The `OpenGLDevice` is created, then passed to a `GLFWApplication` which manages window creation and the main loop. The ultimate goal is for the application to own and provide the input system, further simplifying the program\'s entry point and properly encapsulating platform-specific details within the appropriate module.\\n\\n\x3c!--truncate--\x3e\\n\\n\\n```cpp\\nint main() {\\n    // 1. create the rendering device\\n    const auto opengl = std::make_unique<heliosOpenGl::OpenGLDevice>();\\n    // 2. create the config for the main window\\n    auto cfg = heliosGLFWUtil::GLFWFactory::makeWindowCfg(\\"helios - Simple Cube Renderer\\");\\n\\n    // 3. create the app.\\n    const auto app = heliosGLFWUtil::GLFWFactory::makeApplication(opengl.get());\\n\\n    // 4. create the main window\\n    heliosWinGlfw::GLFWWindow& win = app->createWindow(cfg);\\n\\n    // 5. initialize the app\\n    app->init();\\n    // ... and set focus to the window\\n    app->focus(win);\\n\\n    // get the InputManager\\n    auto& inputManager = app->inputManager();\\n\\n    while (!win.shouldClose()) {\\n        inputManager.tick(0.0f);\\n\\n        if (inputManager.isKeyPressed(heliosInput::Key::ESC)) {\\n            std::cout << \\"Key Pressed [ESC]\\" << std::endl;\\n        }\\n\\n        win.swapBuffers();\\n    }\\n\\n    return EXIT_SUCCESS;\\n}\\n```\\n\\n### Tickable\\nA small milestone has been reached - the first `tick()` is now alive in the main loop, marking the first rhythmic pulse in helios\'s engine (heh!). The clock[^clock] has officially started.\\n\\n[^clock]: `float deltaTime`\\n\\n\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/13/the-great-modular-restructuring","metadata":{"permalink":"/devlog/2025/09/13/the-great-modular-restructuring","source":"@site/devlog/2025-09-13-the-great-modular-restructuring/index.mdx","title":"The Great Modular Restructuring","description":"Refactoring helios namespaces and modules - encapsulating GLFW and managing object lifetimes in C++","date":"2025-09-13T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":1.48,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"The Great Modular Restructuring","description":"Refactoring helios namespaces and modules - encapsulating GLFW and managing object lifetimes in C++","tags":["devlog","helios"],"keywords":["cpp","modules","namespaces","refactoring","glfw","memory management","pointers","references","subsystems"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Updates to main()","permalink":"/devlog/2025/09/14/updates-to-main"},"nextItem":{"title":"Layer Abstraction initiated","permalink":"/devlog/2025/09/07/layer-abstraction has-begun"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### Subsystems, subsystems, subsystems!\\n\\nThe last few days have seen some restructuring in the [helios codebase](https://github.com/garagecraft-games/helios), with namespaces and modules being reorganized. This was mainly driven by a clearer definition of responsibilities for individual classes, which can now be better refined as the implementation progresses.\\n\\n\x3c!--truncate--\x3e\\n\\n As requirements grow, the responsibilities of each module become more apparent, which also influences the abstractions. Encapsulating third-party libraries like [GLFW](https://www.glfw.org/) and providing low-level access to their functions focuses attention more sharply on the demands of a flexible architecture.\\n\\nPointer and reference handling in C++ still feels a bit unfamiliar coming from higher-level languages. This is where you realize how much manual work Java(\'s garbage collector) saves you from. Every allocation in C++ becomes a conscious decision, every object lifetime a deliberate design choice.\\n\\n```cpp\\nint main() {\\n\\n    const auto opengl = std::make_unique<heliosOpenGl::OpenGLDevice>();\\n\\n    const auto app = std::make_unique<heliosGlfw::GLFWApplication>(opengl.get());\\n    auto cfg = heliosGlfw::GLFWWindowConfig{};\\n    cfg.title = \\"helios - Simple Cube Renderer\\";\\n    cfg.frameBufferSizeCallback = [](GLFWwindow* win, const int width, const int height) {\\n        glViewport(0, 0, width, height);\\n    };\\n\\n    heliosGlfw::GLFWWindow& win = app->createWindow(cfg);\\n    app->init();\\n\\n    // move this to the application\\n    auto glfwInput = std::make_unique<heliosInput::glfw::GLFWInput>();\\n    std::unique_ptr<heliosInput::core::InputAdapter> input = std::move(glfwInput);\\n    heliosInput::InputManager inputManager{std::move(input)};\\n\\n    while (!win.shouldClose()) {\\n        if (inputManager.isKeyPressed(heliosInput::Key::ESC, win)) {\\n            std::cout << \\"Key Pressed [ESC]\\" << std::endl;\\n        }\\n\\n        win.swapBuffers().pollEvents();\\n    }\\n\\n    return EXIT_SUCCESS;\\n}\\n```\\n\\nAs I work more with this language, it becomes clear why it remains the industry standard for game development instead of Java or other managed languages. The control you get over memory layout, allocation patterns and performance characteristics is the difference between establishing stable frame times and dealing with unpredictable garbage collection pauses.\\n\\n\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/07/layer-abstraction has-begun","metadata":{"permalink":"/devlog/2025/09/07/layer-abstraction has-begun","source":"@site/devlog/2025-09-07-layer-abstraction has-begun/index.mdx","title":"Layer Abstraction initiated","description":"Architecting the rendering and scene layer - from Vertex to MeshData to device-specific Meshes","date":"2025-09-07T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.69,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Layer Abstraction initiated","description":"Architecting the rendering and scene layer - from Vertex to MeshData to device-specific Meshes","tags":["devlog","helios"],"keywords":["cpp","game engine architecture","rendering layer","scene graph","vertex","mesh","glfw","opengl","testing"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"The Great Modular Restructuring","permalink":"/devlog/2025/09/13/the-great-modular-restructuring"},"nextItem":{"title":"Inb4 Clip Space","permalink":"/devlog/2025/09/05/inbefore-clipspace"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### This time, there will be no Feature Creep - I promise!\\n\\nFrom `Vertex` to `MeshData` to device-specific `Meshes` - over the weekend, I took a sidestep from the math lib to focus on the architectural planning and development of the underlying rendering layer, accompanied by the scene layer that is responsible for abstracting scene graphs away from the actual rendering process.\\n\\n\x3c!--truncate--\x3e\\n\\n### Testing and Examples\\nI set up a testing infrastructure with `glm` as a reference for validating my own implementations. Added an examples subsystem with `GLFW` windowing and `glad` OpenGL context management.\\n\\n### Architecture First\\nThe real test isn\'t whether helios can render a triangle - it\'s whether these early decisions hold up with complex, dynamic scenes. In software architecture, a well-laid-out plan matters. And the deepest insights come from refactoring.\\n\\n\\n<SocialLinks />"},{"id":"/2025/09/05/inbefore-clipspace","metadata":{"permalink":"/devlog/2025/09/05/inbefore-clipspace","source":"@site/devlog/2025-09-05-inbefore-clipspace/index.mdx","title":"Inb4 Clip Space","description":"Implementing vector operations and lookAt function - cross product, dot product, and view matrices","date":"2025-09-05T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.8,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Inb4 Clip Space","description":"Implementing vector operations and lookAt function - cross product, dot product, and view matrices","tags":["devlog","helios"],"keywords":["cpp","vector operations","cross product","dot product","lookAt","view matrix","camera","glm","benchmarks"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Layer Abstraction initiated","permalink":"/devlog/2025/09/07/layer-abstraction has-begun"},"nextItem":{"title":"Model Matrix: Rotations","permalink":"/devlog/2025/09/02/model-matrix-rotations"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n### Updates from the commit log\\n\\n`helios` now has core vector operations: subtraction, dot product, cross product. The `lookAt` function constructs view matrices from `eye`, `target`, and `up` vectors, following [standard methodology](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/change-of-coordinates-and-applications-to-view-matrices).\\n\\n\x3c!--truncate--\x3e\\n\\n### Performance\\nI benchmarked `cross` and `lookAt` since they\'re called frequently during rendering. The `constexpr` optimizations help, but `glm` is still faster - their optimizations go deeper than what I\'ve implemented so far.\\n\\n| Benchmark | Time | CPU | Iterations |\\n|-----------|------|-----|------------|\\n| BM_vec3Constructor/real_time | 5.04 ns | 4.89 ns | 127,890,789 |\\n| BM_glm_vec3Constructor/real_time | 4.25 ns | 4.07 ns | 161,100,528 |\\n| BM_vec3Cross/real_time | 20.1 ns | 19.7 ns | 34,872,072 |\\n| BM_glm_vec3Cross/real_time | 7.28 ns | 7.29 ns | 94,326,910 |\\n| BM_vec3Dot/real_time | 12.2 ns | 11.8 ns | 57,045,623 |\\n| BM_glm_vec3Dot/real_time | 10.1 ns | 9.81 ns | 70,071,613 |\\n\\n### Static\\nHad some symbol collisions from duplicate test function definitions. Using `static` to limit symbol scope to file level solved it - a simple fix from C that still works.\\n\\n<SocialLinks />"},{"id":"/2025/09/02/model-matrix-rotations","metadata":{"permalink":"/devlog/2025/09/02/model-matrix-rotations","source":"@site/devlog/2025-09-02-model-matrix-rotations/index.mdx","title":"Model Matrix: Rotations","description":"Matrix composition for rotations - local space vs world space transformations","date":"2025-09-02T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.55,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Model Matrix: Rotations","description":"Matrix composition for rotations - local space vs world space transformations","tags":["devlog","helios"],"keywords":["linear algebra","model matrix","rotations","matrix composition","local space","world space","opengl","unity"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Inb4 Clip Space","permalink":"/devlog/2025/09/05/inbefore-clipspace"},"nextItem":{"title":"Establishing the Transformation Library","permalink":"/devlog/2025/08/31/establishing-the-transformation-library"}},"content":"import RotationComposition from \\"./img/rotationcomposition.gif\\";\\nimport {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n<center>\\n<img style={{mixBlendMode:\\"screen\\",filter:\\"invert(1)\\"}} src={RotationComposition} />\\n</center>\\nFollowing up on [my article on Model Matrices](/devlog/2025/08/26/model-matrix-transformations), I\'ve written about matrix composition in the context of Model and Rotation matrices.\\n\\n \x3c!--truncate--\x3e\\n\\nThe [article](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-rotation-world-vs-local-origin) covers the difference between rotating around an object\'s own center (local space) versus rotating around a point in world space. It explains why matrix multiplication order matters, how to pre-calculate transformations for better performance, and how glm and Unity handle rotations.\\n\\n\\n<SocialLinks />"},{"id":"/2025/08/31/establishing-the-transformation-library","metadata":{"permalink":"/devlog/2025/08/31/establishing-the-transformation-library","source":"@site/devlog/2025-08-31-establishing-the-transformation-library/index.mdx","title":"Establishing the Transformation Library","description":"Implementing translate, rotate, and scale functions with constexpr for helios.math.transform","date":"2025-08-31T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.58,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Establishing the Transformation Library","description":"Implementing translate, rotate, and scale functions with constexpr for helios.math.transform","tags":["devlog","helios"],"keywords":["cpp","constexpr","transformations","translate","rotate","scale","glm","matrix math","post-multiplication"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Model Matrix: Rotations","permalink":"/devlog/2025/09/02/model-matrix-rotations"},"nextItem":{"title":"Model Matrix: Transformations","permalink":"/devlog/2025/08/26/model-matrix-transformations"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n`translate`, `rotate`, `scale` - done. They now live in [`helios.math.transform`](https://github.com/ThorstenSuckow/helios/tree/main/src/helios/math).\\n\\nI standardized on post-multiplication (`M\' = M * T`) to stay consistent with [`glm`](https://github.com/g-truc/glm). Transformations are applied in [local space](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-transformations-a-change-of-coordinates-perspective).\\n\\n  \x3c!--truncate--\x3e\\n\\n## `constexpr` - mostly\\n`translate` and `scale` are `constexpr`. `rotate` isn\'t - `sin`, `cos`, `sqrt` aren\'t `constexpr` in the standard library, so that\'s that for now.\\n\\nI also skipped the temporary matrices for `translate` and `scale` and went with direct element-wise modification instead. Mathematically equivalent, slightly more efficient.\\n\\nOn to the rendering pipeline!\\n\\n<SocialLinks />"},{"id":"/2025/08/26/model-matrix-transformations","metadata":{"permalink":"/devlog/2025/08/26/model-matrix-transformations","source":"@site/devlog/2025-08-26-model-matrix-transformations/index.mdx","title":"Model Matrix: Transformations","description":"Understanding model matrices as change-of-coordinates transformations in computer graphics","date":"2025-08-26T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.47,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Model Matrix: Transformations","description":"Understanding model matrices as change-of-coordinates transformations in computer graphics","tags":["devlog","helios"],"keywords":["linear algebra","model matrix","transformations","change of coordinates","computer graphics","opengl","math"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Establishing the Transformation Library","permalink":"/devlog/2025/08/31/establishing-the-transformation-library"},"nextItem":{"title":"CMake has entered the chat","permalink":"/devlog/2025/08/23/cmake-has-entered-the-chat"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nWhile porting the rotation matrices for `helios.math.transform`, I took a detour to understand the underlying linear algebra - I wanted to move beyond treating the rotational part of the model matrix as a black box.\\n\\n \x3c!--truncate--\x3e\\n\\nI ended up writing an article that derives the model matrix as a change-of-coordinates transformation. It also shows why pre-rotating the matrix is equivalent to post-rotating the transformed vector. [Read it here](https://thorsten.suckow-homberg.de/docs/articles/computer-graphics/model-matrix-transformations-a-change-of-coordinates-perspective).\\n\\n<SocialLinks />"},{"id":"/2025/08/23/cmake-has-entered-the-chat","metadata":{"permalink":"/devlog/2025/08/23/cmake-has-entered-the-chat","source":"@site/devlog/2025-08-23-cmake-has-entered-the-chat/index.mdx","title":"CMake has entered the chat","description":"Benchmarking mat4 and vec3, switching to CLion and CMake, and comparing helios performance with GLM","date":"2025-08-23T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":2.1,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"CMake has entered the chat","description":"Benchmarking mat4 and vec3, switching to CLion and CMake, and comparing helios performance with GLM","tags":["devlog","helios"],"keywords":["cpp","cmake","benchmarking","google benchmark","clion","glm","mat4","vec3","performance","tooling"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Model Matrix: Transformations","permalink":"/devlog/2025/08/26/model-matrix-transformations"},"nextItem":{"title":"Sundays are for constexpr","permalink":"/devlog/2025/08/17/helios-engine-foundation"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\nOver the weekend, I focused on refactoring mat4 and vec3. Additionally, I\'ve made some adjustments to my toolset.\\n\\n\x3c!--truncate--\x3e\\n\\n## Refactoring and Benchmarking: helios.math.core\\nI took the time to refactor  `vec3` and `mat4` into `helios.math.core`.\\n\\nBy isolating these (and some more) core components, I hope to ensure a more fine grained _separation of concerns_ right from the beginning. I also depend now on [Google Benchmark](https://github.com/google/benchmark) and put `mat4` to the test:\\nSurely, the power house in OpenGL mathematics is [GLM](https://github.com/g-truc/glm) (OpenGL Mathematics  library), which I frequently use. However, to get a hang of C++ I decided to implement some of the (basic) requirements myself.\\n\\nHere\'s a look at the numbers:\\n\\n<center>\\n![](img/benchmark_mat4.png)\\n</center>\\n\\nIn both constructor and multiplication tests, the helios implementation shows a promising performance. Of course I\'m nowhere close to the optimizations of glm which sports much, much more functionality than my basic implementations, but its nonetheless nice to see how the two compare.\\n\\n### Benchmarking Guid Pointer To Implementation\\n\\nRemember my bold claim about the[performance drawbacks of pointer-to-implementation and heap allocation](/devlog/2025/08/17/helios-engine-foundation)? I\u2019ve put together a benchmark [here](https://github.com/garagecraft-games/helios/blob/main/benchmarks/helios/util/Guid.benchmark.cpp), comparing the regular and PIMPL versions. As expected, the latter comes with a noticeable performance hit:\\n\\n\\n| Benchmark                        | Time| Time (CPU) | Iterations |\\n|----------------------------------|------------------|------------|------------|\\n| BM_GuidGenerate                  | 8.70 ns          | 8.40 ns    | 83,743,377 |\\n| BM_GuidPimplGenerate             | 92.3 ns          | 92.7 ns    | 7,920,792  |\\n\\n\\n## A New Workflow: CLion and CMake\\nI\u2019m parting ways with MSVS (for now) in favor of a more automated, cross-platform workflow with [CLion](https://www.jetbrains.com/clion/) and [CMake](https://cmake.org). The goal is to let modern tooling take care of the heavy lifting, especially with dependency management: It turned out that incorporating Google Benchmark was too much of a hassle (for me at last), but CMake did the trick in no time. I also feel pretty much right at home coming from [composer](https://getcomposer.org), [packagist](https://packagist.org) and [npm](https://www.npmjs.com).\\n\\n\\n<center>\\n![](img/screenshot.png)\\n</center>\\n\\n\\nIt wasn\'t without its challenges, and I\'m still navigating the learning curve, but the potential benefits in productivity and project maintainability are promising.\\n\\n## Join Me on the Journey\\nI streamed this entire process live on [Twitch](https://www.twitch.tv/garagecraft_games). If you want to see the code, the benchmarks, and the occasional head-scratching moment as I stumbled through the new CMake setup, you can [catch the VOD here](https://youtube.com/live/FKKh15M_bzY).\\n\\n<SocialLinks />"},{"id":"/2025/08/17/helios-engine-foundation","metadata":{"permalink":"/devlog/2025/08/17/helios-engine-foundation","source":"@site/devlog/2025-08-17-helios-engine-foundation/index.md","title":"Sundays are for constexpr","description":"Building helios from first principles - C++20 modules, constexpr, and the Pimpl idiom","date":"2025-08-17T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":2.74,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Sundays are for constexpr","description":"Building helios from first principles - C++20 modules, constexpr, and the Pimpl idiom","tags":["devlog","helios"],"keywords":["cpp","c++","constexpr","cpp20","cpp20 modules","pimpl","game engine","helios","vec3","guid"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"CMake has entered the chat","permalink":"/devlog/2025/08/23/cmake-has-entered-the-chat"},"nextItem":{"title":"Lost in Translation","permalink":"/devlog/2025/08/16/lost-in-translation"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n\\nFor a game engine, the first step isn\u2019t rendering a scene or simulating complex physics - it\u2019s laying the foundational bricks. This weekend, I ~eased~ dove headfirst into that foundation for my personal C++ engine project, *Helios*, and it was a fantastic journey through the nuances of modern C++ design.\\n\\n\x3c!--truncate--\x3e\\n\\n\\n### Starting with a Clean Slate: C++20 Modules\\nFrom the beginning, I decided to build Helios on a modern footing, which meant embracing C++20 modules. Leaving the legacy of `#include` behind, explicit dependency graphs with `import` and `export` are the goal. Solving a few issues solidified a key lesson: with modules, build scripts are as much a part of your architecture as your C++ code (even though the prospect of a legacy audit makes me a little nervous) .\\n\\n### The `vec3` Story: More Than Just Three Floats\\nThe first real piece of the engine was the humble `vec3`. Sounds simple, right? Yet it became the perfect canvas for exploring modern C++ features. The goal wasn\'t just to make it work, but to make it efficient, so that hundreds operations in between frames can be run in the shortest time possible.\\n\\nI wrapped my head around [`constexpr`](https://en.cppreference.com/w/cpp/language/constexpr.html), amongst others, and used it where applicable: constructors, the `operator[]`, and other accessors were all designed to be usable at compile time, which allows for defining constant vectors like world axes or colors that are baked directly into the program, with zero runtime cost[^static_assert].\\n\\n[^static_assert]: It also enables compile-time validation with [`static_assert`](https://en.cppreference.com/w/cpp/language/static_assert.html), catching bugs before the code even runs.\\n\\n### The Guid Lesson: Choosing the Right Tool\\nNext up was a system for unique object identification. My first instinct for the [`Guid` class](https://github.com/garagecraft-games/helios/blob/main/src/helios/util/Guid.cpp) was to hide the implementation details using the **Pimpl idiom** (_Pointer to Implementation_)[^pimpl]. It\u2019s a classic pattern for reducing compile-time dependencies.\\n\\n[^pimpl]: See https://en.wikipedia.org/wiki/Opaque_pointer (retrieved 17.08.2025)\\n\\nWell, as much as I like the concept behind the [Bridge Pattern](https://en.wikipedia.org/wiki/Bridge_pattern) and its usage in C++, it was completely the wrong tool for this job: Due to the way the memory is allocated for the referenced data structure (additional heap-allocation for every `Guid` that gets created) and due to the fact that a [pointer indirection](https://www.it.uc3m.es/pbasanta/asng/course_notes/pointers_indirection_with_pointers_en.html) for every single `Guid` would be incurred. For a scene graph with many identifiable nodes, this would impose avoidable performance overhead.\\n\\nI scrapped the Pimpl (heh!) and rebuilt Guid as a simple, efficient class wrapping a `uint64_t`. It should be as cheap to use as an `int` - benchmarks tba.\\n\\n![](img/guid.png)\\n\\n### What\'s Next?\\nThe foundation is now in place. I\'m striving for a small math and utility library before I go back to rendering and OpenGL. The process has been a deep dive into not just how C++ features work, but why they are designed the way they are.\\n\\nThe next step is to build on these bricks - to create a scene graph, a Node aggregate, and begin tackling the renderer itself. But I\'ll do so with the confidence that the code it all rests is solid - and, more important - maintainable.\\n\\n----------------"},{"id":"/2025/08/16/lost-in-translation","metadata":{"permalink":"/devlog/2025/08/16/lost-in-translation","source":"@site/devlog/2025-08-16-lost-in-translation/index.md","title":"Lost in Translation","description":"Moving from web development to C++ - the culture shock of pointers, memory management, and build systems","date":"2025-08-16T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":1.11,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Lost in Translation","description":"Moving from web development to C++ - the culture shock of pointers, memory management, and build systems","tags":["devlog","helios"],"keywords":["cpp","c++","web development","java","javascript","memory management","pointers","visual studio","learning cpp"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Sundays are for constexpr","permalink":"/devlog/2025/08/17/helios-engine-foundation"},"nextItem":{"title":"Hello World","permalink":"/devlog/2025/08/15/hello-world"}},"content":"My background is in the web world - I\'ve spent years wrangling Java, JavaScript (and countless frameworks based on it), PHP (from Zend to Laravel over Symfony and self-written solution), and the closest I ever got to the metal was writing C, of which I thought it would give me a head start for a game engine project. In a way, it did: I wasn\'t scared of pointers. But it also gave me a false sense of security.\\n\\n\x3c!--truncate--\x3e\\n\\nMoving to C++ is like a profound culture shock. The language demands a completely different level of discipline. Suddenly, it\'s not just about maintaining memory, it\'s also about ownership. The concept of smart pointers, and the critical role of a destructor is a universe away from the cozy safety of a [garbage collector \u2764\ufe0f](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html) or `==` out of the box. (I now understand the motivation behind Java better.)\\n\\nAnd that\'s before you even get to the build process: No more _save and refresh_ and _hot reloads_. Here, you enter a three-act play with the compiler, the linker, and a mysterious director named VisualStudio 2022 and its ever so confusing tree menus and option dialogs. I guess it\'s time to get familiar with compiler command line options, since they play such a crucial role in C++..."},{"id":"/2025/08/15/hello-world","metadata":{"permalink":"/devlog/2025/08/15/hello-world","source":"@site/devlog/2025-08-15-hello-world/index.mdx","title":"Hello World","description":"The journey begins - from web development to game development, inspired by Advent of Code","date":"2025-08-15T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":0.95,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Hello World","description":"The journey begins - from web development to game development, inspired by Advent of Code","tags":["devlog","helios"],"keywords":["indiedev","gamedev","solodev","cpp","game development","garagecraft games","advent of code","career change"],"authors":["thorstensuckow"]},"unlisted":false,"prevItem":{"title":"Lost in Translation","permalink":"/devlog/2025/08/16/lost-in-translation"}},"content":"import {SocialLinks} from \\"../../src/components/SocialLinks\\";\\n\\n\\n<center>\\n![](img/adventofcode2415.gif)\\n</center>\\n\\nHi everyone!\\n\\nI\'ve been working in [software development](https://www.linkedin.com/in/thorstensuckow/) for a long time now - mostly frontend architecture, large-scale web applications, that kind of thing. I care a lot about [software craftsmanship](https://thorsten.suckow-homberg.de/docs/articles/software-craftsmanship) and building systems that actually make sense.\\n\\nBut then [Day 15 of Advent of Code 2024](https://adventofcode.com/2024/day/15) happened.\\n\\n\x3c!--truncate--\x3e\\n\\nThat warehouse robot puzzle (pictured above) was the tipping point. I\'d been thinking about game development for a while, but solving that problem made me realize: I want to do this.\\n\\nWhat draws me in is the combination of technical depth and visual feedback. Linear algebra becomes something you can see on screen. Architecture decisions directly affect how a game feels. It\'s software development, but in a completely different context.\\n\\nSo I\'m starting [garagecraft games](/).\\n\\nIt\'s a space for me to learn game development from the ground up - building a C++ framework, figuring out rendering pipelines, making mistakes, and documenting the process.\\n\\nI hope you\'ll follow along.\\n\\n <SocialLinks />\\n\\nLet the journey begin,\\n\\nThorsten."}]}}')}}]);