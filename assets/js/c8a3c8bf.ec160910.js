"use strict";(self.webpackChunkgaragecraft_games=self.webpackChunkgaragecraft_games||[]).push([[1391],{2304:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/spaceship_control-23e06d8b18112234ef4a974e79b4e604.gif"},3428:(e,n,t)=>{t.d(n,{R:()=>o});var s=t(4164),a=(t(6540),t(4848));const i=[{name:"GitHub",url:"https://github.com/garagecraft-games",svg:(0,a.jsxs)("svg",{role:"img",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",children:[(0,a.jsx)("title",{children:"GitHub"}),(0,a.jsx)("path",{d:"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"})]})},{name:"X",url:"https://x.com/grgcrft_games",svg:(0,a.jsxs)("svg",{role:"img",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg","aria-label":"X",children:[(0,a.jsx)("title",{children:"X"}),(0,a.jsx)("path",{d:"M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865z",transform:"scale(1.5)"})]})},{name:"BlueSky",url:"https://bsky.app/profile/garagecraft.games",svg:(0,a.jsxs)("svg",{viewBox:"0 0 511.999 452.266",children:[(0,a.jsx)("title",{children:"BlueSky"}),(0,a.jsx)("path",{d:"M110.985 30.442c58.695 44.217 121.837 133.856 145.013 181.961 23.176-48.105 86.322-137.744 145.016-181.961 42.361-31.897 110.985-56.584 110.985 21.96 0 15.681-8.962 131.776-14.223 150.628-18.272 65.516-84.873 82.228-144.112 72.116 103.55 17.68 129.889 76.238 73 134.8-108.04 111.223-155.288-27.905-167.385-63.554-3.489-10.262-2.991-10.498-6.561 0-12.098 35.649-59.342 174.777-167.382 63.554-56.89-58.562-30.551-117.12 72.999-134.8-59.239 10.112-125.84-6.6-144.112-72.116C8.962 184.178 0 68.083 0 52.402c0-78.544 68.633-53.857 110.985-21.96z"})]})},{name:"LinkedIn",url:"https://www.linkedin.com/company/garagecraft-games",svg:(0,a.jsxs)("svg",{role:"img",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",children:[(0,a.jsx)("title",{children:"LinkedIn"}),(0,a.jsx)("path",{d:"M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"})]})},{name:"Twitch",url:"https://twitch.tv/garagecraft_games",svg:(0,a.jsxs)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 512 512",children:[(0,a.jsx)("rect",{width:"512",height:"512",rx:"15%",fill:"#48e65e"}),(0,a.jsx)("path",{d:"m115 101-22 56v228h78v42h44l41-42h63l85-85v-199zm260 185-48 48h-78l-42 42v-42h-65v-204h233zm-48-100v85h-30v-85zm-78 0v85h-29v-85z",fill:"#0d0d27"})]})}],o=function(){const e=i.map(({name:e,url:n,svg:t})=>(0,a.jsx)("div",{className:(0,s.A)("col","socialLink"),children:(0,a.jsx)("a",{href:n,target:"_blank",className:(0,s.A)("button button--outline button--primary","btn"),children:(0,a.jsx)("span",{className:"btnIcon",children:t})})},e));return(0,a.jsx)("div",{className:"container socialContainer",children:(0,a.jsx)("div",{className:(0,s.A)("row"),children:e})})}},5998:e=>{e.exports=JSON.parse('{"permalink":"/devlog/2025/12/16/milestone2-release","source":"@site/devlog/2025-12-16-milestone2-release/index.mdx","title":"Milestone 2: Scene Graph, Gamepad Widgets, and a Flying Spaceship","description":"helios v0.1.0-milestone2 brings scene graph camera integration, gamepad customization, ImGui dev tools, and an interactive spaceship demo","date":"2025-12-16T00:00:00.000Z","tags":[{"inline":false,"label":"DevLog","permalink":"/devlog/tags/devlog","description":"Development log entries documenting the journey of building helios and garagecraft games"},{"inline":false,"label":"helios","permalink":"/devlog/tags/helios","description":"Posts about the helios C++23 game framework - architecture, implementation, and technical deep dives"}],"readingTime":5.72,"hasTruncateMarker":true,"authors":[{"name":"Thorsten Suckow-Homberg","url":"https://thorsten.suckow-homberg.de","imageURL":"https://avatars.githubusercontent.com/u/823135","key":"thorstensuckow","page":null}],"frontMatter":{"title":"Milestone 2: Scene Graph, Gamepad Widgets, and a Flying Spaceship","description":"helios v0.1.0-milestone2 brings scene graph camera integration, gamepad customization, ImGui dev tools, and an interactive spaceship demo","tags":["devlog","helios"],"keywords":["cpp","scene graph","camera","gamepad","imgui","game framework","indiedev","spaceship","input handling","milestone"],"authors":["thorstensuckow"]},"unlisted":false,"nextItem":{"title":"ImGui Integration and Breaking Changes","permalink":"/devlog/2025/12/04/imgui-integration-and-breaking-changes"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},9188:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>d,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var s=t(5998),a=t(4848),i=t(8453),o=t(3428);const r={title:"Milestone 2: Scene Graph, Gamepad Widgets, and a Flying Spaceship",description:"helios v0.1.0-milestone2 brings scene graph camera integration, gamepad customization, ImGui dev tools, and an interactive spaceship demo",tags:["devlog","helios"],keywords:["cpp","scene graph","camera","gamepad","imgui","game framework","indiedev","spaceship","input handling","milestone"],authors:["thorstensuckow"]},d=void 0,h={authorsImageUrls:[void 0]},l=[{value:"Camera Refactor",id:"camera-refactor",level:2},{value:"Game Objects and Commands",id:"game-objects-and-commands",level:2},{value:"Gamepad Config",id:"gamepad-config",level:2},{value:"Units",id:"units",level:2},{value:"Spaceship Demo",id:"spaceship-demo",level:2},{value:"Breaking Changes",id:"breaking-changes",level:2},{value:"Next",id:"next",level:2},{value:"Usage of Copilot in this Milestone",id:"usage-of-copilot-in-this-milestone",level:2},{value:"Code Generation",id:"code-generation",level:3},{value:"Code Review",id:"code-review",level:3},{value:"Manifesto for AI-Augmented Software Craftsmanship",id:"manifesto-for-ai-augmented-software-craftsmanship",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Milestone 2 is out. I originally planned to add some camera controls, but ended up rewriting how cameras integrate with the scene graph entirely. Along the way I also built the foundations for the game object system, a bunch of ImGui debug widgets, and a small spaceship demo where you fly around with a gamepad."}),"\n",(0,a.jsx)(n.h2,{id:"camera-refactor",children:"Camera Refactor"}),"\n",(0,a.jsxs)(n.p,{children:["In milestone_1, ",(0,a.jsx)(n.code,{children:"Camera"})," inherited from ",(0,a.jsx)(n.code,{children:"SceneNode"}),". That worked, but it always felt a bit off - a camera is really just a viewpoint, not a scene object. Having cameras inherit all the scene node behavior led to some awkward edge cases."]}),"\n",(0,a.jsxs)(n.p,{children:["The new design flips it around: ",(0,a.jsx)(n.code,{children:"CameraSceneNode"})," now wraps a ",(0,a.jsx)(n.code,{children:"Camera"})," component. The node participates in the transform hierarchy, the camera handles projection and view logic. Much cleaner separation."]}),"\n",(0,a.jsxs)(n.p,{children:["The big win here is component-wise transform inheritance: Say you have a camera following a spaceship - you probably want the camera to track the ship's position, but not roll when the ship does. With ",(0,a.jsx)(n.code,{children:"TransformType"})," flags you can now pick exactly what gets inherited:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"auto camera = std::make_unique<Camera>();\nauto cameraNode = std::make_unique<CameraSceneNode>(std::move(camera));\n\n// Only inherit translation from parent - ignore rotation and scale\ncameraNode->setInheritance(TransformType::Translation);\n\nauto* nodePtr = scene->addNode(std::move(cameraNode));\n"})}),"\n",(0,a.jsx)(n.p,{children:"The view matrix now comes from the inverse world transform of the camera node, so all the existing hierarchy logic I had for other nodes just works here too."}),"\n",(0,a.jsx)(n.h2,{id:"game-objects-and-commands",children:"Game Objects and Commands"}),"\n",(0,a.jsxs)(n.p,{children:["I went back and forth on the concepts of ECS, but decided to keep it simple with plain old OOP/inheritance: I landed on a basic ",(0,a.jsx)(n.code,{children:"GameObject"})," class with GUID identification and a ",(0,a.jsx)(n.code,{children:"GameWorld"})," container. Nothing fancy, but it covers what helios needs right now."]}),"\n",(0,a.jsxs)(n.p,{children:["The part I like is the ",(0,a.jsx)(n.code,{children:"CommandBuffer"}),". Instead of having input handlers execute game logic directly, they push commands to a buffer that gets processed once per frame. Same inputs in the same frame always produce the same result, and it opens the door for replays later:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"const auto stick = inputSnapshot.gamepadState().left();\nfloat speed      = stick.length();\nspeed = speed <= helios::math::EPSILON_LENGTH ? 0.0f : speed;\n\nhelios::math::vec2f dir = speed > 0.0f\n                            ? stick * (1.0f/speed)\n                            : helios::math::vec2f{0.0f, 0.0f};\n\ncommandBuffer.add(\n    guid,\n    std::make_unique<\n    helios::examples::spaceshipControl::commands::PlayerMoveCommand\n    >(dir, speed)\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"gamepad-config",children:"Gamepad Config"}),"\n",(0,a.jsxs)(n.p,{children:["I've been testing with a couple of different controllers: An old Xbox Elite Series 2 pad (whose best days are long gone) and a GameSir G7 (which really deserves all the praise it got in reviews - minus the dpad). The important thing for debugging was that they all behave slightly differently when it comes to stick drift and axis ranges.\nSo I added ",(0,a.jsx)(n.code,{children:"GamepadSettings"})," for per-controller deadzone thresholds and axis inversion. The deadzones use a radial strategy, which gets rid of that annoying diagonal drift you get with cheap analog sticks. The ",(0,a.jsx)(n.code,{children:"GamepadWidget"})," exposes all of this at runtime with sliders and toggles, which beats recompiling every time I want to try a different threshold."]}),"\n",(0,a.jsx)(n.h2,{id:"units",children:"Units"}),"\n",(0,a.jsx)(n.p,{children:"This is one of those things I should have done from the start: helios now has a proper units system. One helios unit equals one meter, time is measured in seconds. There are conversion helpers for when you need centimeters or milliseconds:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"using namespace helios::core::units;\n\nfloat distance = from(50.0, helios::core::units::Unit::Centimeter);  // 0.5\n"})}),"\n",(0,a.jsx)(n.h2,{id:"spaceship-demo",children:"Spaceship Demo"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"spaceship_control"})," example brings everything together: a small spaceship you fly with gamepad, a camera parented to the ship that inherits only translation (so it follows position but stays level when the ship rotates), and the ImGui overlay for tweaking things live."]}),"\n",(0,a.jsxs)(n.p,{children:["Input flows through ",(0,a.jsx)(n.code,{children:"InputSnapshot"}),", the handler creates movement commands, and the ",(0,a.jsx)(n.code,{children:"CommandBuffer"})," executes them each frame. It's more architecture than a demo strictly needs, but it validates that the systems work together. And flying the spaceship around is genuinely fun."]}),"\n",(0,a.jsx)("center",{children:(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(2304).A+"",width:"1425",height:"847"})})}),"\n",(0,a.jsx)(n.h2,{id:"breaking-changes",children:"Breaking Changes"}),"\n",(0,a.jsx)(n.p,{children:"If you're coming from milestone_1, a few things moved around:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cameras"}),": ",(0,a.jsx)(n.code,{children:"CameraSceneNode"})," now wraps ",(0,a.jsx)(n.code,{children:"Camera"}),", not the other way around. Viewport uses ",(0,a.jsx)(n.code,{children:"setCameraSceneNode()"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Enum sentinels"}),": Renamed from ",(0,a.jsx)(n.code,{children:"COUNT"})," to ",(0,a.jsx)(n.code,{children:"size_"})," everywhere for consistency."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"MeshData"}),": Merged into ",(0,a.jsx)(n.code,{children:"Mesh"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Material"}),": Now owns shader and properties via shared_ptr."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The camera change is the disruptive one, but the component-wise transform inheritance makes the migration worth it."}),"\n",(0,a.jsx)(n.h2,{id:"next",children:"Next"}),"\n",(0,a.jsx)(n.p,{children:"The scene graph works the way I want now, input handling is solid, and I have debug tools that save time. The obvious gap is that everything still looks like colored shapes. Next milestone will focus on shooting bullets and basic collision detection, so the ship doesn't leave the arena."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/ThorstenSuckow/helios/releases",children:"Pre-built binaries can be found here"})," if you want to try the examples."]}),"\n",(0,a.jsx)(n.h2,{id:"usage-of-copilot-in-this-milestone",children:"Usage of Copilot in this Milestone"}),"\n",(0,a.jsx)(n.h3,{id:"code-generation",children:"Code Generation"}),"\n",(0,a.jsx)(n.p,{children:"I ended up spending more time on debug widgets than I originally planned, but having good tools makes everything else faster. I saw this as a good opportunity to try GitHub Copilot for code generation, so I gave it a shot for the ImGui widgets after I implemented the basic ImGui-related API."}),"\n",(0,a.jsx)(n.p,{children:"Copilot generated boilerplate code for the widgets based on my comments and function signatures, which saved me a lot of typing. I still had to tweak the generated code to fit my architecture and style to some extent, but it was a helpful starting point and impressive to see how far models like Claude Opus 4.5 have come."}),"\n",(0,a.jsx)(n.p,{children:"Here's what was built with the help of Claude Opus 4.5, Gemini 3 Pro and ChatGPT-5.1-Codex:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Widget"}),(0,a.jsx)(n.th,{children:"What it does"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"FpsWidget"})}),(0,a.jsx)(n.td,{children:"Frame rate display, target FPS control"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"GamepadWidget"})}),(0,a.jsx)(n.td,{children:"Real-time stick visualization, deadzone config"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"LogWidget"})}),(0,a.jsx)(n.td,{children:"Searchable log console with scope filtering"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"CameraWidget"})}),(0,a.jsx)(n.td,{children:"Position, orientation, projection controls"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"MainMenuWidget"})}),(0,a.jsx)(n.td,{children:"Theme switching, docking options"})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"LogWidget"})," hooks into the logging system through a custom ",(0,a.jsx)(n.code,{children:"ImGuiLogSink"}),". You can filter by scope and search through the output while the app is running. I've already found bugs in minutes that would have taken me much longer with plain console output."]}),"\n",(0,a.jsx)(n.h3,{id:"code-review",children:"Code Review"}),"\n",(0,a.jsx)(n.p,{children:"As a solo dev, I've also come to appreciate GitHub's Copilot code review. No colleagues to catch my mistakes, but at least I get a second pair of \"eyes\" on pull requests before merging."}),"\n",(0,a.jsx)(n.h3,{id:"manifesto-for-ai-augmented-software-craftsmanship",children:"Manifesto for AI-Augmented Software Craftsmanship"}),"\n",(0,a.jsxs)(n.p,{children:["As I have stated in a ",(0,a.jsx)(n.a,{href:"http://garagecraft.games/devlog/2025/11/25/value-driven-game-development-in-the-age-of%20-aI-assistance",children:"previous post"}),", it is important to me that I understand what I'm building. Using AI tools for boilerplate generation and code review helps me focus on the architecture and design decisions, while still ensuring that I grasp the underlying concepts. To add transparency to my use of AI tools, I have documented my approach in ",(0,a.jsx)(n.a,{href:"https://ai-manifesto.software-craftsmanship.dev",children:"The Manifesto for AI-Augmented Software Craftsmanship"}),", which I also discussed ",(0,a.jsx)(n.a,{href:"https://thorsten.suckow-homberg.de/blog/manifesto-for-ai-augmented-software-craftsmanship",children:"in more detail here"}),"."]}),"\n",(0,a.jsx)(o.R,{})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);